<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Java面试指南</title>
  
  <subtitle>最全最专业的面试题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://java.jr-jr.com/"/>
  <updated>2018-06-06T08:31:42.882Z</updated>
  <id>http://java.jr-jr.com/</id>
  
  <author>
    <name>lycying@gmail.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(资源)SWAP的罪与罚</title>
    <link href="http://java.jr-jr.com/2016/07/08/numa-linux/"/>
    <id>http://java.jr-jr.com/2016/07/08/numa-linux/</id>
    <published>2016-07-08T06:24:10.000Z</published>
    <updated>2018-06-06T08:31:42.882Z</updated>
    
    <content type="html"><![CDATA[<p>说个案例：一台Apache服务器，由于其MaxClients参数设置过大，并且恰好又碰到访问量激增，结果内存被耗光，从而引发SWAP，进而负载攀升，最终导致宕机。<br>正所谓：SWAP，性能之大事，死生之地，存亡之道，不可不察也。</p><h2 id="哪些工具可以监测SWAP"><a href="#哪些工具可以监测SWAP" class="headerlink" title="哪些工具可以监测SWAP"></a>哪些工具可以监测SWAP</h2><p>最容易想到的就是free命令了，它指明了当前SWAP的使用情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; free -m</span><br><span class="line">             total       used       free</span><br><span class="line">Swap:        34175      11374      22801</span><br></pre></td></tr></table></figure></p><p>另一个常用的是sar命令，它能列出系统在各个时间的SWAP使用情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; sar -r</span><br><span class="line">kbswpfree kbswpused  %swpused  kbswpcad</span><br><span class="line"> 23345644  11650572     33.29   4656908</span><br><span class="line"> 23346452  11649764     33.29   4656216</span><br><span class="line"> 23346556  11649660     33.29   4650308</span><br><span class="line"> 23346932  11649284     33.29   4649888</span><br><span class="line"> 23346992  11649224     33.29   4648848</span><br></pre></td></tr></table></figure></p><p>不过free命令和sar命令显示的都不是实时数据，如果需要，可以使用vmstat命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; vmstat 1</span><br><span class="line">-----------memory------------- ---swap--</span><br><span class="line">  swpd   free   buff   cache     si   so</span><br><span class="line">11647532 123664 305064 7193168    0    0</span><br><span class="line">11647532 123672 305064 7193172    0    0</span><br><span class="line">11647532 125728 305064 7193468    0    0</span><br><span class="line">11647532 125376 305064 7193476    0    0</span><br><span class="line">11647532 124508 305068 7193624    0    0</span><br></pre></td></tr></table></figure></p><p>每秒刷新一次结果，在SWAP一栏里列出了相关数据，至于si和so的解释，大致如下：</p><ul><li>si: Amount of memory swapped in from disk (/s).</li><li>so: Amount of memory swapped to disk (/s).</li></ul><p>如果它们一直是零当然最好不过了，偶尔不为零也没啥，糟糕的是一直不为零。<br>前面介绍的方法，看到的都是SWAP的整体情况，可是如果我想查看到底是哪些进程使用了SWAP，应该如何操作呢？这个问题有点棘手，我们来研究一下：<br>好消息是top命令能提供这个信息，不过缺省并没有显示，我们需要激活一下：</p><ul><li>打开top；</li><li>按「f」进入选择字段的界面；</li><li>按「p」选择「SWAP」字段；</li><li>按回车确认。</li></ul><p>坏消息是top命令提供的SWAP信息只是一个理论值，或者更直白一点儿来说它根本就是不可信的（在top里SWAP的计算公式是：SWAP=VIRT-RES）。<br>BTW：相比之下，top里的「nFLT」字段更有价值，它表示PageFault的次数。<br>那到底我们能不能获取到进程的SWAP情况呢？别着急，看代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /proc</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pid <span class="keyword">in</span> [0-9]*; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span>=$(cat /proc/<span class="variable">$pid</span>/cmdline)</span><br><span class="line"></span><br><span class="line">    swap=$(</span><br><span class="line">        awk <span class="string">'</span></span><br><span class="line"><span class="string">            BEGIN  &#123; total = 0 &#125;</span></span><br><span class="line"><span class="string">            /Swap/ &#123; total += $2 &#125;</span></span><br><span class="line"><span class="string">            END    &#123; print total &#125;</span></span><br><span class="line"><span class="string">        '</span> /proc/<span class="variable">$pid</span>/smaps</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (( <span class="variable">$swap</span> &gt; 0 )); <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;head&#125;</span>"</span> != <span class="string">"yes"</span> ]]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> -e <span class="string">"PID\tSWAP\tCOMMAND"</span></span><br><span class="line">            head=<span class="string">"yes"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$&#123;pid&#125;</span>\t<span class="variable">$&#123;swap&#125;</span>\t<span class="variable">$&#123;command&#125;</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>说明：请使用root权限来运行此脚本。</p><h2 id="哪些因素可能影响SWAP"><a href="#哪些因素可能影响SWAP" class="headerlink" title="哪些因素可能影响SWAP"></a>哪些因素可能影响SWAP</h2><p>内存不足无疑会SWAP，但有些时候，即便看上去内存很充裕，还可能会SWAP，这种现象被称为SWAP Insanity，罪魁祸首主要有以下几点：</p><p>Swappiness的迷失</p><p>实际上，当可用内存不足时，系统有两个选择：一个是通过SWAP来释放内存，另一个是删除Cache中的Page来释放内存。一个很常见的例子是：当拷贝大文件的时候，时常会发生SWAP现象。这是因为拷贝文件的时候，系统会把文件内容在Cache中按Page来缓存，此时一旦可用内存不足，系统便会倾向于通过SWAP来释放内存。</p><p>内核中的swappiness参数可以用来控制这种行为，缺省情况下，swappiness的值是60：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; sysctl -a | grep swappiness</span><br><span class="line">vm.swappiness = 60</span><br></pre></td></tr></table></figure><p>它的含义是：如果系统需要内存，有百分之六十的概率执行SWAP。知道了这一点，我们很自然的会想到用下面的方法来降低执行SWAP的概率：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; <span class="built_in">echo</span> <span class="string">"vm.swappiness = 1"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">shell&gt; sysctl -p</span><br><span class="line">这样做的确可以降低执行SWAP的概率，但并不意味着永远不会执行SWAP。据网友报道某些情况下，直接改为0有可能出现灵异问题，所以建议改为1。</span><br></pre></td></tr></table></figure></p><p>NUMA的诅咒</p><p>NUMA在MySQL社区有很多讨论，这里不多说了，直击NUMA和SWAP的恩怨纠葛。</p><p>大概了解一下NUMA最核心的numactl命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; numactl --hardware</span><br><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 size: 16131 MB</span><br><span class="line">node 0 free: 100 MB</span><br><span class="line">node 1 size: 16160 MB</span><br><span class="line">node 1 free: 10 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1</span><br><span class="line">  0:  10  20</span><br><span class="line">  1:  20  10</span><br></pre></td></tr></table></figure><p>可以看到系统有两个节点（其实就是两个物理CPU），它们各自分了16G内存，其中零号节点还剩100M内存，一号节点还剩10M内存。设想启动了一个需要11M内存的进程，系统把它分给了一号节点来执行，此时虽然系统总体的可用内存大于该进程需要的内存，但因为一号节点本身剩余的可用内存不足，所以仍然可能会触发SWAP行为。</p><p>需要说明的一点事，numactl命令中看到的各节点剩余内存中时不包括Cache内存的，如果需要知道，我们可以利用drop_caches参数先释放它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; sysctl vm.drop_caches=1</span><br><span class="line">注：这步操作可能会引起系统负载的震荡。</span><br></pre></td></tr></table></figure><p>另：如何确定一个进程的节点及内存分配情况？网络上有现成的脚本。<br><a href="https://raw.githubusercontent.com/jeremycole/blog-files/master/numa-maps-summary.pl" target="_blank" rel="noopener">https://raw.githubusercontent.com/jeremycole/blog-files/master/numa-maps-summary.pl</a></p><p>如果要规避NUMA对SWAP的影响，最简单的方法就是在启动进程的时候禁用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; numactl --interleave=all ...</span><br></pre></td></tr></table></figure><p>此外，内核参数zone_reclaim_mode通常也很重要，当某个节点可用内存不足时，如果为0的话，那么系统会倾向于从远程节点分配内存；如果为1的话，那么系统会倾向于从本地节点回收Cache内存。多数时候，Cache对性能很重要，所以0是一个更好的选择。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; <span class="built_in">echo</span> <span class="string">"vm.zone_reclaim_mode = 0"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">shell&gt; sysctl -p</span><br></pre></td></tr></table></figure><p>早些年，YouTube曾经被SWAP问题困扰过，他们当时的解决方法很极端：删除SWAP！不得不说这真是艺高人胆大，可惜对芸芸众生的我们而言，这实在是太危险了，因为如此一来，一旦内存耗尽，由于没有SWAP的缓冲，系统会立即开始OOM，结果可能会让问题变得更加复杂，所以大家还是安分守己做个老实人吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说个案例：一台Apache服务器，由于其MaxClients参数设置过大，并且恰好又碰到访问量激增，结果内存被耗光，从而引发SWAP，进而负载攀升，最终导致宕机。&lt;br&gt;正所谓：SWAP，性能之大事，死生之地，存亡之道，不可不察也。&lt;/p&gt;
&lt;h2 id=&quot;哪些工具可以监测
      
    
    </summary>
    
      <category term="linux" scheme="http://java.jr-jr.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://java.jr-jr.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>(转)手动释放linux内存cache和脚本定时释放</title>
    <link href="http://java.jr-jr.com/2016/07/03/linux-cache-free/"/>
    <id>http://java.jr-jr.com/2016/07/03/linux-cache-free/</id>
    <published>2016-07-03T05:36:12.000Z</published>
    <updated>2018-06-06T08:31:42.880Z</updated>
    
    <content type="html"><![CDATA[<p>当在Linux下频繁存取文件后，物理内存会很快被用光，当程序结束后，内存不会被正常释放，而是一直作为caching。这个问题，貌似有不少人在问，不过都没有看到有什么很好解决的办法。那么我来谈谈这个问题。</p><h3 id="通常情况"><a href="#通常情况" class="headerlink" title="通常情况"></a>通常情况</h3><p>先来说说free命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># free -m</span></span><br><span class="line">total used free shared buffers cached</span><br><span class="line">Mem: 249 163 86 0 10 94</span><br><span class="line">-/+ buffers/cache: 58 191</span><br><span class="line">Swap: 511 0 511</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li>total 内存总数</li><li>used 已经使用的内存数</li><li>free 空闲的内存数</li><li>shared 多个进程共享的内存总额</li><li>buffers Buffer Cache和cached Page Cache 磁盘缓存的大小</li><li>-buffers/cache (已用)的内存数:used - buffers - cached</li><li>+buffers/cache(可用)的内存数:free + buffers + cached</li><li>可用的memory=free memory+buffers+cached</li></ul><p>有了这个基础后，可以得知，我现在used为163MB，free为86MB，buffer和cached分别为10MB，94MB。<br>那么我们来看看，如果我执行复制文件，内存会发生什么变化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cp -r /etc ~/test/</span></span><br><span class="line"><span class="comment"># free -m</span></span><br><span class="line">total used free shared buffers cached</span><br><span class="line">Mem: 249 244 4 0 8 174</span><br><span class="line">-/+ buffers/cache: 62 187</span><br><span class="line">Swap: 511 0 511</span><br></pre></td></tr></table></figure><p>在我命令执行结束后，used为244MB，free为4MB，buffers为8MB，cached为174MB，天呐，都被cached吃掉了。别紧张，这是为了提高文件读取效率的做法。</p><p>为了提高磁盘存取效率，Linux做了一些精心的设计，除了对dentry进行缓存（用于VFS，加速文件路径名到inode的转换），还采取了两种主要Cache方式：<code>Buffer Cache</code>和<code>Page Cache</code>。前者针对磁盘块的读写，后者针对文件inode的读写。这些Cache有效缩短了 I/O系统调用（比如read，write，getdents）的时间。</p><p>那么有人说过段时间，linux会自动释放掉所用的内存。等待一段时间后，我们使用free再来试试，看看是否有释放？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># free -m</span></span><br><span class="line">total used free shared buffers cached</span><br><span class="line">Mem: 249 244 5 0 8 174</span><br><span class="line">-/+ buffers/cache: 61 188</span><br><span class="line">Swap: 511 0 511</span><br></pre></td></tr></table></figure></p><p>似乎没有任何变化。（实际情况下，内存的管理还与Swap有关）那么我能否手动释放掉这些内存呢？回答是可以的！</p><h3 id="手动释放缓存"><a href="#手动释放缓存" class="headerlink" title="手动释放缓存"></a>手动释放缓存</h3><p>/proc是一个虚拟文件系统，我们可以通过对它的读写操作做为与kernel实体间进行通信的一种手段。也就是说可以通过修改/proc中的文件，来对当前kernel的行为做出调整。那么我们可以通过调整/proc/sys/vm/drop_caches来释放内存。操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/vm/drop_caches</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>首先，/proc/sys/vm/drop_caches的值，默认为0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sync</span></span><br></pre></td></tr></table></figure><p>手动执行sync命令（描述：sync 命令运行 sync 子例程。如果必须停止系统，则运行sync 命令以确保文件系统的完整性。sync 命令将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块 I/O 和读写映射文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 3 &gt; /proc/sys/vm/drop_caches</span></span><br><span class="line"><span class="comment"># cat /proc/sys/vm/drop_caches</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>将/proc/sys/vm/drop_caches值设为3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># free -m</span></span><br><span class="line">total used free shared buffers cached</span><br><span class="line">Mem: 249 66 182 0 0 11</span><br><span class="line">-/+ buffers/cache: 55 194</span><br><span class="line">Swap: 511 0 511</span><br></pre></td></tr></table></figure><p>再来运行free命令，会发现现在的used为66MB，free为182MB，buffers为0MB，cached为11MB。那么有效的释放了buffer和cache。</p><p>有关/proc/sys/vm/drop_caches的用法在下面进行了说明<br>/proc/sys/vm/drop_caches (since Linux 2.6.16)<br>Writing to this file causes the kernel to drop clean caches,dentries and inodes from memory, causing that memory to become free.<br>To free pagecache, use echo 1 &gt; /proc/sys/vm/drop_caches;<br>to free dentries and inodes, use echo 2 &gt; /proc/sys/vm/drop_caches;<br>to free pagecache, dentries and inodes, use echo 3 &gt; /proc/sys/vm/drop_caches.<br>Because this is a non-destructive operation and dirty objects are not freeable, the user should run sync first.</p><h3 id="我的意见"><a href="#我的意见" class="headerlink" title="我的意见"></a>我的意见</h3><p>上述文章就长期以来很多用户对Linux内存管理方面的疑问，给出了一个比较“直观”的回复，我更觉得有点像是核心开发小组的妥协。对于是否需要使用这个值，或向用户提及这个值，我是有保留意见的：</p><p>从man可以看到，这值从2.6.16以后的核心版本才提供，也就是老版的操作系统，如红旗DC 5.0、RHEL 4.x之前的版本都没有；<br>若对于系统内存是否够用的观察，我还是原意去看swap的使用率和si/so两个值的大小；<br>用户常见的疑问是，为什么free这么小，是否关闭应用后内存没有释放？但实际上，我们都知道这是因为Linux对内存的管理与Windows不同，free小并不是说内存不够用了，应该看的是free的第二行最后一个值：-/+ buffers/cache: 58 191，这才是系统可用的内存大小。</p><p>实际项目中告诉我们，如果因为是应用有像内存泄露、溢出的问题，从swap的使用情况是可以比较快速可以判断的，但free上面反而比较难查看。相反，如果在这个时候，我们告诉用户，修改系统的一个值，“可以”释放内存，free就大了。用户会怎么想？不会觉得操作系统“有问题”吗？所以说，我觉得既然核心是可以快速清空buffer或cache，也不难做到（这从上面的操作中可以明显看到），但核心并没有这样做（默认值是0），我们就不应该随便去改变它。一般情况下，应用在系统上稳定运行了，free值也会保持在一个稳定值的，虽然看上去可能比较小。</p><p>当发生内存不足、应用获取不到可用内存、OOM错误等问题时，还是更应该去分析应用方面的原因，如用户量太大导致内存不足、发生应用内存溢出等情况，否则，清空buffer，强制腾出free的大小，可能只是把问题给暂时屏蔽了。</p><p>我觉得，排除内存不足的情况外，除非是在软件开发阶段，需要临时清掉buffer，以判断应用的内存使用情况；或应用已经不再提供支持，即使应用对内存的时候确实有问题，而且无法避免的情况下，才考虑定时清空buffer。（可惜，这样的应用通常都是运行在老的操作系统版本上，上面的操作也解决不了）。而生产环境下的服务器可以不考虑手工释放内存，这样会带来更多的问题。记住内存是拿来用的，不是拿来看的。不像windows。</p><p>无论你的真实物理内存有多少，他都要拿硬盘交换文件来读。这也就是windows为什么常常提示虚拟空间不足的原因，你们想想多无聊，在内存还有大部分的时候，拿出一部分硬盘空间来充当内存。硬盘怎么会快过内存，所以我们看linux，只要不用swap的交换空间，就不用担心自己的内存太少。如果常常swap用很多,可能你就要考虑加物理内存了，这也是linux看内存是否够用的标准哦。当然这仅代表我个人意见，也欢迎大家来交流讨论。</p><p>以上内容转载于考试大，下面是我写的一个内存释放的脚本，分享给大家：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /root/satools/freemem.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">used=`free -m | awk <span class="string">'NR==2'</span> | awk <span class="string">'&#123;print $3&#125;'</span>`</span><br><span class="line">free=`free -m | awk <span class="string">'NR==2'</span> | awk <span class="string">'&#123;print $4&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"==========================="</span> &gt;&gt; /var/<span class="built_in">log</span>/mem.log</span><br><span class="line">date &gt;&gt; /var/<span class="built_in">log</span>/mem.log</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Memory usage | [Use：<span class="variable">$&#123;used&#125;</span>MB][Free：<span class="variable">$&#123;free&#125;</span>MB]"</span> &gt;&gt; /var/<span class="built_in">log</span>/mem.log</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$free</span> -le 100 ] ; <span class="keyword">then</span></span><br><span class="line">                sync &amp;&amp; <span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">                sync &amp;&amp; <span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">                sync &amp;&amp; <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"OK"</span> &gt;&gt; /var/<span class="built_in">log</span>/mem.log</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Not required"</span> &gt;&gt; /var/<span class="built_in">log</span>/mem.log</span><br></pre></td></tr></table></figure></p><p>将脚本添加到crond任务，定时执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo "*/30 * * * * root /root/satools/freemem.sh" &gt;&gt; /etc/crondtab</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当在Linux下频繁存取文件后，物理内存会很快被用光，当程序结束后，内存不会被正常释放，而是一直作为caching。这个问题，貌似有不少人在问，不过都没有看到有什么很好解决的办法。那么我来谈谈这个问题。&lt;/p&gt;
&lt;h3 id=&quot;通常情况&quot;&gt;&lt;a href=&quot;#通常情况&quot; c
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="linux" scheme="http://java.jr-jr.com/tags/linux/"/>
    
      <category term="cache" scheme="http://java.jr-jr.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>(转)多线程经典问题</title>
    <link href="http://java.jr-jr.com/2016/07/03/thread-basic/"/>
    <id>http://java.jr-jr.com/2016/07/03/thread-basic/</id>
    <published>2016-07-03T05:29:27.000Z</published>
    <updated>2018-06-06T08:31:42.885Z</updated>
    
    <content type="html"><![CDATA[<p>很多核心面试题来源于多线程(Multi-Threading)和集合框架(Collections Framework)，理解核心线程概念时，娴熟的实际经验是必需的。这篇文章收集了Java线程方面一些典型的问题，这些问题经常被高级工程师所问到。</p><h4 id="JAVA中多线程同步是什么？"><a href="#JAVA中多线程同步是什么？" class="headerlink" title="JAVA中多线程同步是什么？"></a>JAVA中多线程同步是什么？</h4><p>在多线程程序下，同步能控制对共享资源的访问。如果没有同步，当一个Java线程在修改一个共享变量时，另外一个线程正在使用或者更新同一个变量，这样容易导致程序出现错误的结果。</p><h4 id="解释实现多线程的几种方法"><a href="#解释实现多线程的几种方法" class="headerlink" title="解释实现多线程的几种方法?"></a>解释实现多线程的几种方法?</h4><p>一Java线程可以实现Runnable接口或者继承Thread类来实现，当你打算多重继承时，优先选择实现Runnable。</p><h4 id="THREAD-START-与THREAD-RUN-有什么区别？"><a href="#THREAD-START-与THREAD-RUN-有什么区别？" class="headerlink" title="THREAD.START()与THREAD.RUN()有什么区别？"></a>THREAD.START()与THREAD.RUN()有什么区别？</h4><p>Thread.start()方法(native)启动线程，使之进入就绪状态，当cpu分配时间该线程时，由JVM调度执行run()方法。</p><h4 id="为什么需要RUN-和START-方法，我们可以只用RUN-方法来完成任务吗？"><a href="#为什么需要RUN-和START-方法，我们可以只用RUN-方法来完成任务吗？" class="headerlink" title="为什么需要RUN()和START()方法，我们可以只用RUN()方法来完成任务吗？"></a>为什么需要RUN()和START()方法，我们可以只用RUN()方法来完成任务吗？</h4><p>我们需要run()&amp;start()这两个方法是因为JVM创建一个单独的线程不同于普通方法的调用，所以这项工作由线程的start方法来完成，start由本地方法实现，需要显示地被调用，使用这俩个方法的另外一个好处是任何一个对象都可以作为线程运行，只要实现了Runnable接口，这就避免因继承了Thread类而造成的Java的多继承问题。</p><h4 id="什么是THREADLOCAL类，怎么使用它？"><a href="#什么是THREADLOCAL类，怎么使用它？" class="headerlink" title="什么是THREADLOCAL类，怎么使用它？"></a>什么是THREADLOCAL类，怎么使用它？</h4><p>ThreadLocal是一个线程级别的局部变量，并非“本地线程”。ThreadLocal为每个使用该变量的线程提供了一个独立的变量副本，每个线程修改副本时不影响其它线程对象的副本(译者注)。</p><p>下面是线程局部变量(ThreadLocal variables)的关键点：</p><p>一个线程局部变量(ThreadLocal variables)为每个线程方便地提供了一个单独的变量。</p><p>ThreadLocal实例通常作为静态的私有的(private static)字段出现在一个类中，这个类用来关联一个线程。</p><p>当多个线程访问ThreadLocal实例时，每个线程维护ThreadLocal提供的独立的变量副本。</p><p>常用的使用可在DAO模式中见到，当DAO类作为一个单例类时，数据库链接(connection)被每一个线程独立的维护，互不影响。(基于线程的单例)<br>ThreadLocal难于理解，下面这些引用连接有助于你更好的理解它。</p><p>《Good article on ThreadLocal on IBM DeveloperWorks 》、《理解ThreadLocal》、《Managing data : Good example》、《Refer Java API Docs》</p><h4 id="什么时候抛出INVALIDMONITORSTATEEXCEPTION异常，为什么？"><a href="#什么时候抛出INVALIDMONITORSTATEEXCEPTION异常，为什么？" class="headerlink" title="什么时候抛出INVALIDMONITORSTATEEXCEPTION异常，为什么？"></a>什么时候抛出INVALIDMONITORSTATEEXCEPTION异常，为什么？</h4><p>调用wait()/notify()/notifyAll()中的任何一个方法时，如果当前线程没有获得该对象的锁，那么就会抛出IllegalMonitorStateException的异常(也就是说程序在没有执行对象的任何同步块或者同步方法时，仍然尝试调用wait()/notify()/notifyAll()时)。</p><p>由于该异常是RuntimeExcpetion的子类，所以该异常不一定要捕获(尽管你可以捕获只要你愿意).作为RuntimeException，此类异常不会在wait(),notify(),notifyAll()的方法签名提及。</p><h4 id="SLEEP-、SUSPEND-和WAIT-之间有什么区别？"><a href="#SLEEP-、SUSPEND-和WAIT-之间有什么区别？" class="headerlink" title="SLEEP()、SUSPEND()和WAIT()之间有什么区别？"></a>SLEEP()、SUSPEND()和WAIT()之间有什么区别？</h4><p>Thread.sleep()使当前线程在指定的时间处于“非运行”（Not Runnable）状态。线程一直持有对象的监视器。比如一个线程当前在一个同步块或同步方法中，其它线程不能进入该块或方法中。如果另一线程调用了interrupt()方法，它将唤醒那个“睡眠的”线程。</p><p>注意：sleep()是一个静态方法。这意味着只对当前线程有效，一个常见的错误是调用t.sleep()，（这里的t是一个不同于当前线程的线程）。即便是执行t.sleep()，也是当前线程进入睡眠，而不是t线程。t.suspend()是过时的方法，使用suspend()导致线程进入停滞状态，该线程会一直持有对象的监视器，suspend()容易引起死锁问题。</p><p>object.wait()使当前线程出于“不可运行”状态，和sleep()不同的是wait是object的方法而不是thread。调用object.wait()时，线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步，把当前线程添加到等待队列中，随后另一线程可以同步同一个对象锁来调用object.notify()，这样将唤醒原来等待中的线程，然后释放该锁。基本上wait()/notify()与sleep()/interrupt()类似，只是前者需要获取对象锁。</p><h4 id="在静态方法上使用同步时会发生什么事？"><a href="#在静态方法上使用同步时会发生什么事？" class="headerlink" title="在静态方法上使用同步时会发生什么事？"></a>在静态方法上使用同步时会发生什么事？</h4><p>同步静态方法时会获取该类的“Class”对象，所以当一个线程进入同步的静态方法中时，线程监视器获取类本身的对象锁，其它线程不能进入这个类的任何静态同步方法。它不像实例方法，因为多个线程可以同时访问不同实例同步实例方法。</p><h4 id="当一个同步方法已经执行，线程能够调用对象上的非同步实例方法吗？"><a href="#当一个同步方法已经执行，线程能够调用对象上的非同步实例方法吗？" class="headerlink" title="当一个同步方法已经执行，线程能够调用对象上的非同步实例方法吗？"></a>当一个同步方法已经执行，线程能够调用对象上的非同步实例方法吗？</h4><p>可以，一个非同步方法总是可以被调用而不会有任何问题。实际上，Java没有为非同步方法做任何检查，锁对象仅仅在同步方法或者同步代码块中检查。如果一个方法没有声明为同步，即使你在使用共享数据Java照样会调用，而不会做检查是否安全，所以在这种情况下要特别小心。一个方法是否声明为同步取决于临界区访问(critial section access),如果方法不访问临界区(共享资源或者数据结构)就没必要声明为同步的。</p><p>下面有一个示例说明：Common类有两个方法synchronizedMethod1()和method1()，MyThread类在独立的线程中调用这两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Common</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“synchronizedMethod1 called”);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(“synchronizedMethod1 done”);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“Method <span class="number">1</span> called”);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(“Method <span class="number">1</span> done”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> Common common;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, <span class="keyword">int</span> no, Common object)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">common = object;</span><br><span class="line">id = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“Running Thread” + <span class="keyword">this</span>.getName());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">common.synchronizedMethod1();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">common.method1();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Common c = <span class="keyword">new</span> Common();</span><br><span class="line">MyThread t1 = <span class="keyword">new</span> MyThread(“MyThread-<span class="number">1</span>″, <span class="number">0</span>, c);</span><br><span class="line">MyThread t2 = <span class="keyword">new</span> MyThread(“MyThread-<span class="number">2</span>″, <span class="number">1</span>, c);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是程序的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Running ThreadMyThread-1</span><br><span class="line">synchronizedMethod1 called</span><br><span class="line">Running ThreadMyThread-2</span><br><span class="line">Method 1 called</span><br><span class="line">synchronizedMethod1 <span class="keyword">done</span></span><br><span class="line">Method 1 <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>结果表明即使synchronizedMethod1()方法执行了，method1()也会被调用。</p><h4 id="在一个对象上两个线程可以调用两个不同的同步实例方法吗？"><a href="#在一个对象上两个线程可以调用两个不同的同步实例方法吗？" class="headerlink" title="在一个对象上两个线程可以调用两个不同的同步实例方法吗？"></a>在一个对象上两个线程可以调用两个不同的同步实例方法吗？</h4><p>不能，因为一个对象已经同步了实例方法，线程获取了对象的对象锁。所以只有执行完该方法释放对象锁后才能执行其它同步方法。<br>看下面代码示例非常清晰：Common 类 有synchronizedMethod1()和synchronizedMethod2()方法，MyThread调用这两个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Common</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“synchronizedMethod1 called”);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(“synchronizedMethod1 done”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“synchronizedMethod2 called”);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(“synchronizedMethod2 done”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> Common common;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, <span class="keyword">int</span> no, Common object)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">common = object;</span><br><span class="line">id = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“Running Thread” + <span class="keyword">this</span>.getName());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">common.synchronizedMethod1();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">common.synchronizedMethod2();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Common c = <span class="keyword">new</span> Common();</span><br><span class="line">MyThread t1 = <span class="keyword">new</span> MyThread(“MyThread-<span class="number">1</span>″, <span class="number">0</span>, c);</span><br><span class="line">MyThread t2 = <span class="keyword">new</span> MyThread(“MyThread-<span class="number">2</span>″, <span class="number">1</span>, c);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>死锁就是两个或两个以上的线程被无限的阻塞，线程之间相互等待所需资源。这种情况可能发生在当两个线程尝试获取其它资源的锁，而每个线程又陷入无限等待其它资源锁的释放，除非一个用户进程被终止。就JavaAPI而言，线程死锁可能发生在一下情况。</p><ul><li>当两个线程相互调用Thread.join()</li><li>当两个线程使用嵌套的同步块，一个线程占用了另外一个线程必需的锁，互相等待时被阻塞就有可能出现死锁。</li></ul><h4 id="什么是线程饿死，什么是活锁？"><a href="#什么是线程饿死，什么是活锁？" class="headerlink" title="什么是线程饿死，什么是活锁？"></a>什么是线程饿死，什么是活锁？</h4><p>线程饿死和活锁虽然不想是死锁一样的常见问题，但是对于并发编程的设计者来说就像一次邂逅一样。<br>当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI中线程活锁可能发生在以下情形：</p><ul><li>当所有线程在程序中执行Object.wait(0)，参数为0的wait方法。程序将发生活锁直到在相应的对象上有线程调用Object.notify()或者Object.notifyAll()。</li><li>当所有线程卡在无限循环中。</li></ul><p>这里的问题并不详尽，我相信还有很多重要的问题并未提及，您认为还有哪些问题应该包括在上面呢？欢迎在评论中分享任何形式的问题与建议。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多核心面试题来源于多线程(Multi-Threading)和集合框架(Collections Framework)，理解核心线程概念时，娴熟的实际经验是必需的。这篇文章收集了Java线程方面一些典型的问题，这些问题经常被高级工程师所问到。&lt;/p&gt;
&lt;h4 id=&quot;JAVA
      
    
    </summary>
    
      <category term="初级" scheme="http://java.jr-jr.com/categories/%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="thread" scheme="http://java.jr-jr.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>位运算符和位运算(与,或,异或等)的用途</title>
    <link href="http://java.jr-jr.com/2016/07/03/java-bit/"/>
    <id>http://java.jr-jr.com/2016/07/03/java-bit/</id>
    <published>2016-07-03T05:19:23.000Z</published>
    <updated>2018-06-06T08:31:42.872Z</updated>
    
    <content type="html"><![CDATA[<h3 id="“按位与”运算符-amp"><a href="#“按位与”运算符-amp" class="headerlink" title="“按位与”运算符(&amp;)"></a>“按位与”运算符(&amp;)</h3><h4 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h4><p>参加运算的两个数据，按二进位进行“与”运算，如果两个相应的二进位都为1，则该位的结果值为1，否则为0，即：<br>0&amp;0=0，0&amp;1=0，1&amp;0=0，1&amp;1=1.</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>清零<br>运算对象：原来的数中为1的位，新数中相应位为0。</li><li>取一个数中某些指定位。<br>如想要取一个整数a（占2个字节）的低（高）字节，只需将a与八进制的377（177400）按位与即可。</li><li>保留某一个数的某一位。<br>与一个数进行&amp;运算，此数在该位取1。<br>例如：9&amp;5可写算式如下： 00001001 (9的二进制补码)&amp;00000101 (5的二进制补码)　00000001 (1的二进制补码)可见9&amp;5=1。<br>按位与运算通常用来对某些位清0或保留某些位。例如把a 的高八位清 0 ， 保留低八位， 可作 a&amp;255 运算 ( 255 的二进制数为0000000011111111)。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">9</span>,b=<span class="number">5</span>,c;</span><br><span class="line">c=a&amp;b;</span><br><span class="line">printf(<span class="string">"a=%d\nb=%d\nc=%d\n"</span>,a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="按位或运算符"><a href="#按位或运算符" class="headerlink" title="按位或运算符(|)"></a>按位或运算符(|)</h3><h4 id="运算规则-1"><a href="#运算规则-1" class="headerlink" title="运算规则"></a>运算规则</h4><p>参加运算的两个数据，按二进位进行“或”运算，如果两个相应的二进位都为0，则该位的结果值为0，否则为1，即：<br>0|0=0，0|1=1，1|0=1，1|1=1。</p><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><p>对一个数据的某些位定值为1。</p><p>3.例如：9|5可写算式如下： 00001001|00000101<br>00001101 (十进制为13)可见9|5=13<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">9</span>,b=<span class="number">5</span>,c;</span><br><span class="line">c=a|b;</span><br><span class="line">printf(<span class="string">"a=%d\nb=%d\nc=%d\n"</span>,a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="“异或”运算符"><a href="#“异或”运算符" class="headerlink" title="“异或”运算符(^)"></a>“异或”运算符(^)</h3><p>也称XOR运算符。</p><h4 id="运算规则-2"><a href="#运算规则-2" class="headerlink" title="运算规则"></a>运算规则</h4><p>若参加运算的两个二进位同号，则结果为0（假）；异号则为1（真），即：<br>0^0=0，0^1=1，1^0=1，1^1=0.</p><h4 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h4><ul><li>使特定位翻转<br>假设有01111010，想使其低4位翻转，可以将它与00001111进行^运算。</li><li>与0相^，保留原值</li><li>交换两个值，不用临时变量<br>假如a=3,b=4。想将a和b的值互换，可以用以下赋值语句实现：<br>a=a^b; b=b^a; a=a^b;</li></ul><p>例如9^5可写成算式如下： 00001001^00000101 00001100 (十进制为12)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">9</span>;</span><br><span class="line">a=a^<span class="number">15</span>;</span><br><span class="line">printf(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="“取反”运算符-～"><a href="#“取反”运算符-～" class="headerlink" title="“取反”运算符(～)"></a>“取反”运算符(～)</h3><h4 id="运算规则-3"><a href="#运算规则-3" class="headerlink" title="运算规则"></a>运算规则</h4><p>~是一个单目（元）运算符，用来对一个二进制数按位取反，即将0变1，1变0。</p><h4 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a>用途</h4><p>使一个整数a的最低位为0,可以用：a=a&amp;~1;<br>例如～9的运算为： ~(0000000000001001)结果为：1111111111110110</p><h3 id="左移运算符-lt-lt"><a href="#左移运算符-lt-lt" class="headerlink" title="左移运算符(&lt;&lt;)"></a>左移运算符(&lt;&lt;)</h3><h4 id="运算规则-4"><a href="#运算规则-4" class="headerlink" title="运算规则"></a>运算规则</h4><p>用来将一个数的各二进位全部左移若干位，右补0，高位左移后溢出，舍弃不起作用。</p><h4 id="用途-4"><a href="#用途-4" class="headerlink" title="用途"></a>用途</h4><p>左移一位相当于乘以2<br>例如：设 a=15，a&gt;&gt;2　表示把000001111右移为00000011(十进制3)。 应该说明的是，对于有符号数，在右移时，符号位将随同移动。当为正数时， 最高位补0，而为负数时，符号位为1，最高位是补0或是补1 取决于编译系统的规定。Turbo C和很多系统规定为补1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">unsigned a,b;</span><br><span class="line">printf(<span class="string">"input a number: "</span>);</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">b=a&gt;&gt;<span class="number">5</span>;</span><br><span class="line">b=b&amp;<span class="number">15</span>;</span><br><span class="line">printf(<span class="string">"a=%d\tb=%d\n"</span>,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请再看一例!<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line"><span class="keyword">char</span> a=<span class="string">'a'</span>,b=<span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">int</span> p,c,d;</span><br><span class="line">p=a;</span><br><span class="line">p=(p&lt;&lt;<span class="number">8</span>)|b;</span><br><span class="line">d=p&amp;<span class="number">0xff</span>;</span><br><span class="line">c=(p&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>;</span><br><span class="line">printf(<span class="string">"a=%d\nb=%d\nc=%d\nd=%d\n"</span>,a,b,c,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="右移运算符-gt-gt"><a href="#右移运算符-gt-gt" class="headerlink" title="右移运算符(&gt;&gt;)"></a>右移运算符(&gt;&gt;)</h3><h4 id="运算规则-5"><a href="#运算规则-5" class="headerlink" title="运算规则"></a>运算规则</h4><p>用来将一个数的各二进位全部右移若干位，移到右端的低位被舍弃，对无符号数，高位补0；<br>对有符号数，左边移入0（“逻辑右移”）或1（“算术右移”）</p><h4 id="用途-5"><a href="#用途-5" class="headerlink" title="用途"></a>用途</h4><p>右移一位相当于除以2</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;“按位与”运算符-amp&quot;&gt;&lt;a href=&quot;#“按位与”运算符-amp&quot; class=&quot;headerlink&quot; title=&quot;“按位与”运算符(&amp;amp;)&quot;&gt;&lt;/a&gt;“按位与”运算符(&amp;amp;)&lt;/h3&gt;&lt;h4 id=&quot;运算规则&quot;&gt;&lt;a href=&quot;#运算规
      
    
    </summary>
    
      <category term="初级" scheme="http://java.jr-jr.com/categories/%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="object" scheme="http://java.jr-jr.com/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>(转)Java HashMap的死循环</title>
    <link href="http://java.jr-jr.com/2016/07/03/java-hashmap-loop/"/>
    <id>http://java.jr-jr.com/2016/07/03/java-hashmap-loop/</id>
    <published>2016-07-03T03:14:43.000Z</published>
    <updated>2018-06-06T08:31:42.873Z</updated>
    
    <content type="html"><![CDATA[<p>在淘宝内网里看到同事发了贴说了一个CPU被100%的线上故障，并且这个事发生了很多次，原因是在Java语言在并发情况下使用HashMap造成Race Condition，从而导致死循环。这个事情我4、5年前也经历过，本来觉得没什么好写的，因为Java的HashMap是非线程安全的，所以在并发下必然出现问题。但是，我发现近几年，很多人都经历过这个事（在网上查“HashMap Infinite Loop”可以看到很多人都在说这个事）所以，觉得这个是个普遍问题，需要写篇疫苗文章说一下这个事，并且给大家看看一个完美的“Race Condition”是怎么形成的。</p><h3 id="问题的症状"><a href="#问题的症状" class="headerlink" title="问题的症状"></a>问题的症状</h3><p>从前我们的Java代码因为一些原因使用了HashMap这个东西，但是当时的程序是单线程的，一切都没有问题。后来，我们的程序性能有问题，所以需要变成多线程的，于是，变成多线程后到了线上，发现程序经常占了100%的CPU，查看堆栈，你会发现程序都Hang在了HashMap.get()这个方法上了，重启程序后问题消失。但是过段时间又会来。而且，这个问题在测试环境里可能很难重现。</p><p>我们简单的看一下我们自己的代码，我们就知道HashMap被多个线程操作。而Java的文档说HashMap是非线程安全的，应该用ConcurrentHashMap。<br>但是在这里我们可以来研究一下原因。</p><h3 id="Hash表数据结构"><a href="#Hash表数据结构" class="headerlink" title="Hash表数据结构"></a>Hash表数据结构</h3><p>我需要简单地说一下HashMap这个经典的数据结构。</p><p>HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个&lt;key, value&gt;插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表。</p><p>我们知道，如果table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷（可参看《Hash Collision DoS 问题》）。</p><p>所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的无素都需要被重算一遍。这叫rehash，这个成本相当的大。</p><p>相信大家对这个基础知识已经很熟悉了。</p><h3 id="HashMap的rehash源代码"><a href="#HashMap的rehash源代码" class="headerlink" title="HashMap的rehash源代码"></a>HashMap的rehash源代码</h3><p>下面，我们来看一下Java的HashMap的源代码。</p><p>Put一个Key,Value对到Hash表中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//算Hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//如果该key已被插入，则替换掉旧的value （链接操作）</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//该key不存在，需要增加一个结点</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查容量是否超标<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize</span></span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新建一个更大尺寸的hash表，然后把数据从老的Hash表中迁移到新的Hash表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//创建一个新的Hash Table</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">//将Old Hash Table上的数据迁移到New Hash Table上</span></span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迁移的源代码，注意高亮处：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//下面这段代码的意思是：</span></span><br><span class="line">    <span class="comment">//  从OldTable里摘一个元素出来，然后放到NewTable中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这个代码算是比较正常的。而且没有什么问题。</p><h3 id="正常的ReHash的过程"><a href="#正常的ReHash的过程" class="headerlink" title="正常的ReHash的过程"></a>正常的ReHash的过程</h3><p>画了个图做了个演示。<br><img src="/java_hashmap_reshash.jpg" alt=""><br>我假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。<br>最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。<br>接下来的三个步骤是Hash表 resize成4，然后所有的&lt;key,value&gt; 重新rehash的过程</p><h3 id="并发下的Rehash"><a href="#并发下的Rehash" class="headerlink" title="并发下的Rehash"></a>并发下的Rehash</h3><p>1）假设我们有两个线程。我用红色和浅蓝色标注了一下。</p><p>我们再回头看一下我们的 transfer代码中的这个细节：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next; <span class="comment">// &lt;--假设线程一执行到这里就被调度挂起了</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><p>而我们的线程二执行完成了。于是我们有下面的这个样子。</p><p><img src="/java_hashmap_reshash2.jpg" alt=""></p><p>注意，因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。<br>2）线程一被调度回来执行。</p><p>先是执行 newTalbe[i] = e;<br>然后是e = next，导致了e指向了key(7)，<br>而下一次循环的next = e.next导致了next指向了key(3)<br><img src="/java_hashmap_reshash3.jpg" alt=""><br>3）一切安好。<br><img src="/java_hashmap_reshash4.jpg" alt=""><br>线程一接着工作。把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移。</p><p>4）环形链接出现。<br><img src="/java_hashmap_reshash5.jpg" alt=""><br>e.next = newTable[i] 导致  key(3).next 指向了 key(7)</p><p>注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p>于是，当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinite Loop。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>有人把这个问题报给了Sun，不过Sun不认为这个是一个问题。因为HashMap本来就不支持并发。要并发就用ConcurrentHashmap</p><p><a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6423457" target="_blank" rel="noopener">http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6423457</a></p><p>我在这里把这个事情记录下来，只是为了让大家了解并体会一下并发环境下的危险。</p><p>参考：<a href="http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html" target="_blank" rel="noopener">http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html</a></p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在淘宝内网里看到同事发了贴说了一个CPU被100%的线上故障，并且这个事发生了很多次，原因是在Java语言在并发情况下使用HashMap造成Race Condition，从而导致死循环。这个事情我4、5年前也经历过，本来觉得没什么好写的，因为Java的HashMap是非线程
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="thread" scheme="http://java.jr-jr.com/tags/thread/"/>
    
      <category term="collections" scheme="http://java.jr-jr.com/tags/collections/"/>
    
  </entry>
  
  <entry>
    <title>作为高级Java，你应该了解的Linux知识</title>
    <link href="http://java.jr-jr.com/2016/06/04/linux-overview/"/>
    <id>http://java.jr-jr.com/2016/06/04/linux-overview/</id>
    <published>2016-06-04T04:19:57.000Z</published>
    <updated>2018-06-06T08:31:42.881Z</updated>
    
    <content type="html"><![CDATA[<p>软件领域有两种人才，一种是工程型的，一种是研究型的。在Linux领域里，相对于搞内核研究的来说，搞命令行的就属于工程型。工程型也有他自己的苦衷，比如，背诵命令就挺痛苦的，一般来说不太推荐背诵，第一覆盖的面不广，第二记的快忘的也快，浪费脑细胞。牛逼的记法就是用，用时间来冲淡烟云，见微知著，并体验其中的喜悦。爱她并天天抱她上床，真爱才成。</p><p><code>Linux</code>命令好像还真不少，根本原因就是软件多，也有像<code>ag</code>这样的命令想替代<code>grep</code>,但大多数命令古老而坚挺。不是因为这些软件设计的有多好，原因是一些软件最开始入驻了系统，时间久了，就变成了一种约定，这种习惯改变代价太大，就像把所有键盘的<code>L</code>和<code>F</code>换一下一样。</p><p>这片文章假定你已经了解大多数Linux命令，并了解操作系统的基本元素。如果你现在了解的命令还不足10个，下面的内容就不用看了。除了最基本的东西，本文列出一些对你的面试最常见的最能加分的地方，有些组合可能是你没见过的技巧。但本文仅仅是给出一个大致的轮廓和印象，为以后的专题性考察点作一个序。</p><p>本文中出现的所有命令，应该熟记并熟练使用。</p><h3 id="几种比较典型的Linux系统"><a href="#几种比较典型的Linux系统" class="headerlink" title="几种比较典型的Linux系统"></a>几种比较典型的Linux系统</h3><p>首先对目前的Linux版本有个大体的印象，大体分Desktop版和Server版，已经是百花齐放。</p><ul><li><strong>Ubuntu</strong> 最常见的Linux个人发行版，一位有情怀的南非富豪，有了钱你也可以这么做</li><li><strong>CentOS</strong> 最常用Linux服务器发新版，RHEL的开放版本，因版权而生的轮子</li><li><strong>Arch</strong>  滚动升级，海量二进制包，社区活跃，个人最爱</li><li><strong>Gentoo</strong> 安装软件需要从源码开始编译，稳定，但用起来会很痛</li><li><strong>LFS</strong> 从零构建Linux，跟着做一遍，Linux每根毛都看的清清楚楚</li><li><strong>Kali</strong> 专做渗透用的，代表了发行版的一个发展路径，就是领域</li></ul><h4 id="首先要了解的概念"><a href="#首先要了解的概念" class="headerlink" title="首先要了解的概念"></a>首先要了解的概念</h4><ul><li><strong>KISS</strong> Keep it Simple and Stupid，据说是哲学</li><li><strong>一切皆文件</strong> 通常是文件的东西叫文件，进程、磁盘等也被抽象成了文件，比较离谱的管道、设备、socket等，也是文件。这是Linux最重要的组织方式。</li><li><strong>管道</strong> <code>|</code> 分隔，前面命令的输出作为后面命令的输入，可以串联多个</li><li><strong>重定向</strong> <ul><li><code>&lt;</code> 将文件做为命令的输入</li><li><code>&gt;</code> 将命令的输出输出到文件</li><li><code>&gt;&gt;</code> 将命令的输出追加到文件</li></ul></li><li><strong>SHELL</strong> 首先确认你的shell，一般最常用的是bash，也有不少用csh，zsh等的，通过<code>echo $SHELL</code>可以看到当前用户的shell，对应的配置文件也要相应改变。比如<code>.zshrc</code>,<code>.bashrc</code><h3 id="四大元素"><a href="#四大元素" class="headerlink" title="四大元素"></a>四大元素</h3>进入linux，我们首先关注的是四个元素：内存，cpu，存储，网络。Linux提供了足够的命令，让你窥探它的每个角落。接下来的命令都是些最常用的，不管精通不精通，想不起来要打屁股。<br><img src="/linux-4.png" alt="linux-4.-ng"></li></ul><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul><li>使用<code>top</code>查看cpu的load，使用shift+p按照cpu排序。需要了解wa，us等都是什么意思</li><li>使用<code>uptime</code>查看系统启动时间和load，load是什么意思呢？什么算是系统过载？这是个高频问题，别怪我没告诉你</li><li><code>ps</code>命令勃大茎深，除了查进程号外，你还需要知道R、S、D、T、Z、&lt;、N状态位的含义</li><li><code>top</code>和<code>ps</code>很多功能是相通的，比如<code>watch &quot;ps -mo %cpu,%mem,pid,ppid,command ax&quot;</code> 相当于top的进程列表；<code>top -n 1 -bc</code> 和<code>ps -ef</code>的结果相似。</li><li>有生就有死，可以用<code>kill</code>杀死进程。对java来说，需要关注<code>kill -9</code>、<code>kill -15</code>、<code>kill -3</code>的含义，kill的信号太多了，可以用<code>kill -l</code>查看，搞懂大多数信号大有裨益。</li><li>如果暂时不想死，可以通过<code>&amp;</code>符号在后台执行，比如<code>tail -f a.log &amp;</code>。<code>jobs</code>命令可以查看当前后台的列表，想恢复的话，使用<code>fg</code>回到幕前。这都是终端作业，当你把<code>term</code>关了你的后台命令也会跟着消失，所以想让你的程序继续执行的话，需要<code>nohup</code>命令，此命令需要牢记</li><li><strong>mpstat</strong> 显示了系统中 CPU 的各种统计信</li><li>了解cpu亲和性<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4></li><li><code>free -m</code> 命令，了解free、used、cached、swap各项的含义</li><li><code>cat /proc/meminfo</code> 查看更详细的内存信息<br>细心的同学可能注意到，CPU和内存的信息，通过top等不同的命令显示的数值是一样的。</li><li><code>slabtop</code> 用来显示内核缓存占用情况，比如遍历大量文件造成缓存目录项。曾在生产环境中遇到因执行<code>find /</code>造成<code>dentry_cache</code>耗尽服务器内存。</li><li><code>vmstat</code> 命令是我最喜欢也最常用的命令之一，可以以最快的速度了解系统的运行状况。每个参数的意义都要搞懂。</li><li><strong>swapon、swapoff</strong> 开启，关闭交换空间</li><li><strong> sar</strong>  又一统计类轮子，一般用作采样工具</li></ul><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ul><li>使用<code>df -h</code>查看系统磁盘使用概况</li><li><strong>lsblk</strong> 列出块设备信息</li><li><strong>du</strong> 查看目录或者文件大小</li></ul><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li><strong>rsync</strong> 强大的同步工具，可以增量哦</li><li><strong>netstat</strong>  查看Linux中网络系统状态信息，各种</li><li><strong>ss</strong>  它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</li><li><strong>curl、wget</strong> 模拟请求工具、下载工具。如wget -r <a href="http://site" target="_blank" rel="noopener">http://site</a> 将下载整个站点</li><li><strong>ab</strong> Apache服务器的性能测试工具</li><li><strong>ifstat</strong> 统计网络接口流量状态</li><li><strong>nslookup</strong> 查询域名DNS信息的工具，在内网根据ip查询域名是爽爆了</li><li><strong>nc</strong> 网络工具中的瑞士军刀，不会用真是太可惜了</li><li><strong>arp</strong> 可以显示和修改IP到MAC转换表</li><li><strong>traceroute</strong> 显示数据包到主机间的路径，俗称几跳，跳的越少越快</li><li><strong>tcpdump</strong> 不多说了，去下载wireshark了</li><li><strong>wall</strong> 向当前所有打开的终端上输出信息。使用<code>who</code>命令发现女神正在终端上，可以求爱</li></ul><p>网络方面推荐安装体验一下kaliLinux，上面的工具会让你high到极点。</p><h3 id="如何组织起来"><a href="#如何组织起来" class="headerlink" title="如何组织起来"></a>如何组织起来</h3><p>linux的命令很有意思，除了各种stat来监控状态，也有各种trace来进行深入的跟踪，也有各种top来统计资源消耗者，也有各种ls来查看系统硬件如lsblk、lsusb、lscpi。基本上跟着你的感觉走，就能找到相应的工具，因为约定是系统中最强大的导向。</p><p>Linux有个比较另类的目录<code>/proc</code>，承载了每个命令的蹂躏。像<code>sysctl</code>命令，就是修改的<code>/proc/sys</code>目录下的映射项。不信看看<code>find /proc/sys -type f | wc -l</code>和<code>sysctl -a| wc -l</code>的结果是不是很像？</p><p>/proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。只不过以文件系统的方式为访问系统内核数据的操作提供接口。系统的所有状态都逃不过它的火眼金睛。例如:</p><ul><li><code>cat /proc/vmstat</code> 看一下，是不是和<code>vmstat</code>命令的输出很像?</li><li><code>cat /proc/meminfo</code> 是不是最全的内存信息</li><li><code>cat /proc/slabinfo</code> 这不就是<code>slabtop</code>的信息么</li><li><code>cat /proc/devices</code> 已经加载对设备们</li><li><code>cat /proc/loadavg</code> load avg原来就躺在这里啊</li><li><code>cat /proc/stat</code> 所有的CPU活动信息</li><li><code>ls /proc/$pid/fd</code> 静静地躺着<code>lsof</code>的结果</li></ul><h3 id="一般排查问题的方法"><a href="#一般排查问题的方法" class="headerlink" title="一般排查问题的方法"></a>一般排查问题的方法</h3><p>一般排查问题也是围绕着内存cpu等几个元素去排查。下图是一张大体的排查故障或者性能问题的过程，看图，不多说。</p><p><img src="/linux_2016-06-04_11-46-40.png" alt="linux_2016-06-04_11-46-40.png"></p><h3 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h3><p>下面举例从具体应用场景来说明各种命令的组合应用，此类场景数不胜数，需要个人积累。但强烈建议将sed和awk练的熟练一些。</p><h4 id="怎么查看某个Java进程里面占用CPU最高的一个线程具体信息？"><a href="#怎么查看某个Java进程里面占用CPU最高的一个线程具体信息？" class="headerlink" title="怎么查看某个Java进程里面占用CPU最高的一个线程具体信息？"></a>怎么查看某个Java进程里面占用CPU最高的一个线程具体信息？</h4><ul><li>获取进程中占用CPU最高的线程，计为n。<ul><li>使用top <code>top -H -p pid</code>，肉眼观察之</li><li>使用ps  <code>ps -mo spid,lwp,stime,time,%cpu -p pid</code></li></ul></li><li>将线程号转化成十六进制<code>printf 0x%x n</code></li><li>使用jstack找到相应进程，打印线程后的100行信息 <code>jstack -l pid| grep spid -A 100</code><h4 id="统计每种网络状态的数量"><a href="#统计每种网络状态的数量" class="headerlink" title="统计每种网络状态的数量"></a>统计每种网络状态的数量</h4><code>netstat -ant | awk &#39;{print $6}&#39; | sort  | uniq -c  | sort -n -k 1 -r</code><br>首先使用netstat查看列表，使用’awk’截取第六列，使用<code>uniq</code>进行统计，并对统计结果排序。当然，也可以这样。<br><code>netstat -ant | awk &#39;{arr[$6]++}END{for(i in arr){print arr[i]&quot; &quot;i }}&#39;  | sort -n -k 1 -r</code><br>这和“分析apache日志，给出当日访问ip的降序列表”是一样的问题。<h4 id="怎么查看哪个进程在用swap"><a href="#怎么查看哪个进程在用swap" class="headerlink" title="怎么查看哪个进程在用swap"></a>怎么查看哪个进程在用swap</h4>首先要了解/proc/$pid/smaps里有我们所需要的各种信息，其中Swap字段即是我们所需要的。只要循环遍历一下即可。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `<span class="built_in">cd</span> /proc;ls |grep <span class="string">"^[0-9]"</span>|awk <span class="string">' $0 &gt;100'</span>` ;<span class="keyword">do</span> awk <span class="string">'/Swap:/&#123;a=a+$2&#125;END&#123;print '</span><span class="string">"<span class="variable">$i</span>"</span><span class="string">',a/1024"M"&#125;'</span> /proc/<span class="variable">$i</span>/smaps ;<span class="keyword">done</span> |sort -k2nr</span><br></pre></td></tr></table></figure></li></ul><p>最后，附上<a href="http://www.brendangregg.com/" target="_blank" rel="noopener">http://www.brendangregg.com/</a> 的大图一张<br><img src="/linux_observability_tools.png" alt="linux_observability_tools.png"></p><p>看到这里，是不是觉得自己变帅了呢？希望能够引起你的兴趣。<br><img src="/xiuxiulian.jpg" alt="xiuxiulian.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;软件领域有两种人才，一种是工程型的，一种是研究型的。在Linux领域里，相对于搞内核研究的来说，搞命令行的就属于工程型。工程型也有他自己的苦衷，比如，背诵命令就挺痛苦的，一般来说不太推荐背诵，第一覆盖的面不广，第二记的快忘的也快，浪费脑细胞。牛逼的记法就是用，用时间来冲淡烟
      
    
    </summary>
    
      <category term="高级" scheme="http://java.jr-jr.com/categories/%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="linux" scheme="http://java.jr-jr.com/tags/linux/"/>
    
      <category term="shell" scheme="http://java.jr-jr.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>(转)  Linux进程状态(ps stat)之R、S、D、T、Z、X</title>
    <link href="http://java.jr-jr.com/2016/05/03/ps-state/"/>
    <id>http://java.jr-jr.com/2016/05/03/ps-state/</id>
    <published>2016-05-03T05:44:22.000Z</published>
    <updated>2018-06-06T08:31:42.882Z</updated>
    
    <content type="html"><![CDATA[<p>Linux是一个多用户，多任务的系统，可以同时运行多个用户的多个程序，就必然会产生很多的进程，而每个进程会有不同的状态。</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p><strong>Linux进程状态：R (TASK_RUNNING)，可执行状态。</strong></p><p>只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。<br>很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。</p><h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><p><strong>Linux进程状态：S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。</strong></p><p>处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。<br>通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p><strong>Linux进程状态：D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。</strong></p><p>与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。<br>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。<br>而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。（参见《linux内核异步中断浅析》）<br>在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。<br>linux系统中也存在容易捕捉的TASK_UNINTERRUPTIBLE状态。执行vfork系统调用后，父进程将进入TASK_UNINTERRUPTIBLE状态，直到子进程调用exit或exec（参见《神奇的vfork》）。<br>通过下面的代码就能得到处于TASK_UNINTERRUPTIBLE状态的进程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!vfork()) sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译运行，然后ps一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kouu@kouu-one:~/<span class="built_in">test</span>$ ps -ax | grep a\.out</span><br><span class="line">4371 pts/0    D+     0:00 ./a.out</span><br><span class="line">4372 pts/0    S+     0:00 ./a.out</span><br><span class="line">4374 pts/1    S+     0:00 grep a.out</span><br></pre></td></tr></table></figure></p><p>然后我们可以试验一下TASK_UNINTERRUPTIBLE状态的威力。不管kill还是kill -9，这个TASK_UNINTERRUPTIBLE状态的父进程依然屹立不倒。</p><h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p><strong>Linux进程状态：T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。</strong></p><p>向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。）<br>向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。<br>当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。<br>对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是表示进程暂停下来。<br>而TASK_TRACED状态相当于在TASK_STOPPED之上多了一层保护，处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过ptrace系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。</p><h3 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h3><p><strong>Linux进程状态：Z (TASK_DEAD – EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。</strong></p><p>进程在退出的过程中，处于TASK_DEAD状态。<br>在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。<br>之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。<br>当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。<br>父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。<br>子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。<br>通过下面的代码能够制造一个EXIT_ZOMBIE状态的进程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fork())</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译运行，然后ps一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kouu@kouu-one:~/<span class="built_in">test</span>$ ps -ax | grep a\.out</span><br><span class="line">10410 pts/0    S+     0:00 ./a.out</span><br><span class="line">10411 pts/0    Z+     0:00 [a.out]</span><br><span class="line">10413 pts/1    S+     0:00 grep a.out</span><br></pre></td></tr></table></figure></p><p>只要父进程不退出，这个僵尸状态的子进程就一直存在。那么如果父进程退出了呢，谁又来给子进程“收尸”？<br>当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。<br>1号进程，pid为1的进程，又称init进程。<br>linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：</p><ul><li>执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；</li><li>在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；<br>init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。</li></ul><h3 id="X"><a href="#X" class="headerlink" title="X"></a>X</h3><p><strong>Linux进程状态：X (TASK_DEAD – EXIT_DEAD)，退出状态，进程即将被销毁。</strong></p><p>而进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程（进程？线程？参见《linux线程浅析》）。或者父进程通过设置SIGCHLD信号的handler为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。）<br>此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。<br>进程的初始状态<br>进程是通过fork系列的系统调用（fork、clone、vfork）来创建的，内核（或内核模块）也可以通过kernel_thread函数创建内核进程。这些创建子进程的函数本质上都完成了相同的功能——将调用进程复制一份，得到子进程。（可以通过选项参数来决定各种资源是共享、还是私有。）<br>那么既然调用进程处于TASK_RUNNING状态（否则，它若不是正在运行，又怎么进行调用？），则子进程默认也处于TASK_RUNNING状态。<br>另外，在系统调用调用clone和内核函数kernel_thread也接受CLONE_STOPPED选项，从而将子进程的初始状态置为 TASK_STOPPED。<br>进程状态变迁<br>进程自创建以后，状态可能发生一系列的变化，直到进程退出。而尽管进程状态有好几种，但是进程状态的变迁却只有两个方向——从TASK_RUNNING状态变为非TASK_RUNNING状态、或者从非TASK_RUNNING状态变为TASK_RUNNING状态。<br>也就是说，如果给一个TASK_INTERRUPTIBLE状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入TASK_RUNNING状态），然后再响应SIGKILL信号而退出（变为TASK_DEAD状态）。并不会从TASK_INTERRUPTIBLE状态直接退出。<br>进程从非TASK_RUNNING状态变为TASK_RUNNING状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为TASK_RUNNING，然后将其task_struct结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。<br>而进程从TASK_RUNNING状态变为非TASK_RUNNING状态，则有两种途径：</p><ul><li>响应信号而进入TASK_STOPED状态、或TASK_DEAD状态；</li><li>执行系统调用主动进入TASK_INTERRUPTIBLE状态（如nanosleep系统调用）、或TASK_DEAD状态（如exit系统调用）；或由于执行系统调用需要的资源得不到满足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）。<br>显然，这两种情况都只能发生在进程正在CPU上执行的情况下。</li></ul><p>内核模块代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">—————-killd.c—————-</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> #<span class="meta-keyword">include</span> #<span class="meta-keyword">include</span> <span class="comment">//for_each_process</span></span></span><br><span class="line">MODULE_LICENSE(“BSD”);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pid = <span class="number">-1</span>;</span><br><span class="line">module_param(pid, <span class="keyword">int</span>, S_IRUGO);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">killd_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">p</span>;</span></span><br><span class="line">printk(KERN_ALERT “killd: force D status process to death\n”);</span><br><span class="line">printk(KERN_ALERT “killd: pid=%d\n”, pid);</span><br><span class="line"><span class="comment">//read_lock(&amp;tasklist_lock);</span></span><br><span class="line">for_each_process(p)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;pid == pid)&#123;</span><br><span class="line">printk(“killd: found\n”);</span><br><span class="line">set_task_state(p, TASK_STOPPED);</span><br><span class="line">printk(KERN_ALERT “killd: aha, dead already\n”);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printk(“<span class="keyword">not</span> found”);</span><br><span class="line"><span class="comment">//read_unlock(&amp;tasklist_lock);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">killd_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_ALERT “killd: bye\n”);</span><br><span class="line">&#125;</span><br><span class="line">module_init(killd_init);</span><br><span class="line">module_exit(killd_exit);</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">—–Makefile————</span><br><span class="line">obj-m := killd.o</span><br></pre></td></tr></table></figure><p>编译模块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C yourkerneltree M=`<span class="built_in">pwd</span>` modules</span><br></pre></td></tr></table></figure></p><p>插入模块的时候提供D状态的进程号，就可以将其转换为stopped状态，使用普通kill就可以杀死。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./insmod ./killd.ko pid=1234</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux是一个多用户，多任务的系统，可以同时运行多个用户的多个程序，就必然会产生很多的进程，而每个进程会有不同的状态。&lt;/p&gt;
&lt;h3 id=&quot;R&quot;&gt;&lt;a href=&quot;#R&quot; class=&quot;headerlink&quot; title=&quot;R&quot;&gt;&lt;/a&gt;R&lt;/h3&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="linux" scheme="http://java.jr-jr.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>LRU缓存就像你的鞋柜，附实现攻略</title>
    <link href="http://java.jr-jr.com/2016/04/07/lru/"/>
    <id>http://java.jr-jr.com/2016/04/07/lru/</id>
    <published>2016-04-07T06:22:03.000Z</published>
    <updated>2018-06-06T08:31:42.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>今天我们讲一下怎么实现一个简单的最近最少使用（LRU）的缓存。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>LRU是Least Recently Used 的缩写，意为“最近最少使用”。<br>LRU缓存简单的说就是缓存一定量的数据，当超过设定的阈值时就把一些过期的数据删除掉。<br>举个生活中的例子，你有一堆鞋子，肯定是最新买的最喜欢穿的放在身边，鞋柜满了的话，如果你不是壕，扔鞋子也会先扔破鞋。</p><p>如图，把格子想想成你的鞋柜。一个格子只能放一双鞋子哦。<br><img src="/lru.png" alt="lru"></p><ul><li>新数据插入到链表头部；(新鞋子放在最外边)</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；(刚穿过的鞋子放在最外面)</li><li>当链表满的时候，将链表尾部的数据丢弃。(鞋柜满了，就需要忍痛扔破鞋)</li></ul><p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Java里面实现LRU缓存通常有多种选择，一种是使用LinkedHashMap，一种是自己设计数据结构，使用链表+HashMap，灵活度更高的可以自定义使用方式。<br>搞Java的同学真是幸福，因为LinkedHashMap就是一个天生的LRU。<br><img src="/happy.gif" alt="lru"></p><p>先来看一下LinkedHashMap的构造方法。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LinkedHashMap(<span class="keyword">int</span> initialCapacity,</span><br><span class="line"><span class="keyword">float</span> loadFactor,</span><br><span class="line"><span class="keyword">boolean</span> accessOrder) &#123;</span><br><span class="line"><span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line"><span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>注意accessOrder这个参数，为true使用访问顺序排序，false使用插入顺序排序。使用访问顺序排序，就是LRU。</li><li>当需要添加元素时，会调用removeEldestEntry方法，这里就是实现LRU元素过期机制的地方，默认的情况下removeEldestEntry方法只返回false表示元素永远不过期。</li></ul><p>根据以上介绍，可以使用继承方式实现一个最简单的LRU.只需要覆盖removeEldestEntry方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  LRU_MAX_CAPACITY = <span class="number">1024</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LRULinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> java.util.LinkedHashMap#removeEldestEntry(java.util.Map.Entry)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(size() &gt; LRU_MAX_CAPACITY) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>使用LRU要注意以下几点:</p><ul><li>缓存的数据是否真正有热点数据</li><li>缓存的大小一定要限制，否则会有内存撑爆的危险</li><li>老生常谈，高并发下一定要注意LRU操作的同步</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;今天我们讲一下怎么实现一个简单的最近最少使用（LRU）的缓存。&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;h
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="arithmetic" scheme="http://java.jr-jr.com/tags/arithmetic/"/>
    
  </entry>
  
  <entry>
    <title>java的long，天生的陷阱专家</title>
    <link href="http://java.jr-jr.com/2016/04/06/java-long-concurrent/"/>
    <id>http://java.jr-jr.com/2016/04/06/java-long-concurrent/</id>
    <published>2016-04-06T08:54:35.000Z</published>
    <updated>2018-06-06T08:31:42.873Z</updated>
    
    <content type="html"><![CDATA[<p>工作忙，好久没更新了。有些朋友反映有些东西太难了些。这次来段小程序解解压。</p><p>话说，有这么一个小类A。简单的就像嘘了一泡。那么请问在并发的情况下，会有神马问题，会打印Error么。</p><h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != a &amp;&amp; <span class="number">-1</span> != a) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宋仲基哥哥，你快来，告诉我怎么可能打印Error。<br>那我们先上一段测试程序。</p><h3 id="上测试"><a href="#上测试" class="headerlink" title="上测试"></a>上测试</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> A v = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    v.set0();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    v.set1();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">final</span> Thread t3 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    v.check();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际测试证明，Error出来了，囧。<br>一个中级的程序员绝对不应该犯如此低级的错误。</p><h3 id="上原因"><a href="#上原因" class="headerlink" title="上原因"></a>上原因</h3><p>问题出在两个地方</p><ul><li>第一，if判断不是原子的，有可能0!=a通过后，被另外一个线程设置成了0，此时-1!=a 也成立,就囧了</li><li>第二，在32位机器上，一些赋值操作不是原子性的。在处理大于32位操作时需要处理两次。</li></ul><p>看看java的Primitive Types介绍，木有long和double.<br><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2</a></p><p>concurrent包里面，有不少原子类，如AtomicInteger，AtomicLong等。在设计并发的代码中，我们要尽量的使用这些封装好的原子操作。更下流的做法，使用lock或者synchronized保证操作的原子性。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>32位的老古董机器还有不少，32位机器本身只支持4GB的内存，去掉其他资源占用，能留给java进程的也就2G左右，what a pity！<br>那32的机器有什么优势呢，有些公司还喜欢把64位的大内存宿主机虚拟化成n个32位的小VM，来增加资源的利用率，尤其是docker部署的机器。主要原因是64位的jvm内部的指针占用的是64位（更宽的寻址），相比起来，占用了更多的内存，大约为32位的1.5倍。<br>要想在64位的jvm上节省更多的内存，可以使用 -XX:+UseCompressedOops，参数开启指针压缩，会节省不少内存。在“一定条件下”，会自动开启此指令。</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>扯远了，早点休息，麻烦关下灯 我要和宋仲基睡了<br><img src="/szj.jpg" alt="javaobject"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作忙，好久没更新了。有些朋友反映有些东西太难了些。这次来段小程序解解压。&lt;/p&gt;
&lt;p&gt;话说，有这么一个小类A。简单的就像嘘了一泡。那么请问在并发的情况下，会有神马问题，会打印Error么。&lt;/p&gt;
&lt;h3 id=&quot;上代码&quot;&gt;&lt;a href=&quot;#上代码&quot; class=&quot;h
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="thread" scheme="http://java.jr-jr.com/tags/thread/"/>
    
      <category term="object" scheme="http://java.jr-jr.com/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>妈妈再也不用担心别人问我是否真正用过redis了</title>
    <link href="http://java.jr-jr.com/2015/12/31/redis-vvv/"/>
    <id>http://java.jr-jr.com/2015/12/31/redis-vvv/</id>
    <published>2015-12-31T06:55:48.000Z</published>
    <updated>2018-06-06T08:31:42.883Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新…</p><p>Redis最近几年很火。笔者很羞愧，很长时间内以为和Memcache一样，只能做缓存。事实上Redis功能丰富，十八般武艺样样具全，几乎适用于互联网行业的各个场景，包括存储。但Redis存储相当的贵，而且大文件不适合这种场景。<br>Redis从设计到运维到使用，都是很大的话题，在面试中被问到的概率越来越大，大部分都是使用问题。简单的了解以下内容，妈妈再也不用担心别人问我是否真正用过redis了。</p><h3 id="Memcache与Redis的区别"><a href="#Memcache与Redis的区别" class="headerlink" title="Memcache与Redis的区别"></a>Memcache与Redis的区别</h3><p>现在的硬盘速度很不给力，所以才有了各种各样的缓存，redis最初是作为缓存设计的，相对于另一个缓存大明星Memcache，它们有以下不同。</p><h4 id="存储方式不同"><a href="#存储方式不同" class="headerlink" title="存储方式不同"></a>存储方式不同</h4><p>Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。<br>Redis有部份存在硬盘上，这样能保证数据的持久性。</p><h4 id="数据支持类型"><a href="#数据支持类型" class="headerlink" title="数据支持类型"></a>数据支持类型</h4><p>Memcache对数据类型支持相对简单。<br>Redis有复杂的数据类型。可以玩很多花样。</p><h4 id="使用底层模型不同"><a href="#使用底层模型不同" class="headerlink" title="使用底层模型不同"></a>使用底层模型不同</h4><p>它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。<br>Redis直接自己构建了VM机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p><h3 id="Redis支持的数据类型"><a href="#Redis支持的数据类型" class="headerlink" title="Redis支持的数据类型"></a>Redis支持的数据类型</h3><p>Redis支持5种数据类型strings, hashes, lists, sets, sorted sets</p><ul><li>strings 简单字符串，底层使用sds实现</li><li>lists 简单列表，按照需求，底层使用双向链表(linkedlist)或者压缩列表(ziplist)实现</li><li>sets 无序set，底层存储使用intset或者hashtable</li><li>sorted sets 有序set，底层使用压缩列表或者”跳跃表+哈希”实现</li><li>hashes 哈希表，按照需求，底层使用压缩列表或者哈希表实现</li></ul><h3 id="Redis的回收策略"><a href="#Redis的回收策略" class="headerlink" title="Redis的回收策略"></a>Redis的回收策略</h3><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul><h3 id="Redis小命令"><a href="#Redis小命令" class="headerlink" title="Redis小命令"></a>Redis小命令</h3><p>其他命令参考<a href="http://redisdoc.com" target="_blank" rel="noopener">http://redisdoc.com</a></p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#连接上redis_001.jr-jr.com，指定host和port</span></span><br><span class="line">redis-cli -h redis_001.jr-jr.com -p 3306</span><br><span class="line"><span class="comment">#注意。可以直接在后面跟上命令</span></span><br><span class="line">redis-cli -h redis_001.jr-jr.com -p 3306 monitor</span><br></pre></td></tr></table></figure><h4 id="MONITOR"><a href="#MONITOR" class="headerlink" title="MONITOR"></a>MONITOR</h4><p>MONITOR是一个调试命令，返回服务器处理的每一个命令，它能帮助我们了解在数据库上发生了什么操作。配合grep可以查看是否有你想要的操作。<br>由于MONITOR命令返回服务器处理的所有的命令, 所以在性能上会有一些消耗。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h redis_001.jr-jr.com -p 3306<span class="built_in"> monitor </span>| grep <span class="string">"nnn"</span></span><br></pre></td></tr></table></figure></p><h4 id="SLOWLOG"><a href="#SLOWLOG" class="headerlink" title="SLOWLOG"></a>SLOWLOG</h4><p>通过SLOWLOG可以读取慢查询日志。<br>使用SLOWLOG LEN就可以获取当前慢日志长度。<br>使用SLOWLOG GET N就可以获取最近N条慢日志。<br>使用SLOWLOG RESET命令重置慢日志。一旦执行，将丢失以前的所有慢日志。</p><h4 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h4><p>详细信息可以看这里<br><a href="http://redis.io/commands/info" target="_blank" rel="noopener">http://redis.io/commands/info</a><br><a href="http://redisdoc.com/server/info.html" target="_blank" rel="noopener">http://redisdoc.com/server/info.html</a></p><p>主要关注Memory帧<br>used_memory : 由 Redis 分配器分配的内存总量，以字节（byte）为单位<br>used_memory_rss : 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。</p><p>rdb_changes_since_last_save 如果频繁进行save操作，会引起redis卡顿，需要定位<br>connected_clients 有多少个客户端连接，看详细列表可以使用<code>CLIENT LIST</code></p><p>instantaneous_ops_per_sec 另外关注ops，达到2w需要高度关注</p><p>keyspace_hits<br>keyspace_misses 缓存命中，顾名思义，被当作缓存使用时有意义</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>进入我们的主旋律，怎么运用redis，具体redis的运维，交给专业DBA吧。不明白的redis指令，希望自己能查查。<br>啊啊啊啊，妈妈再也不用担心别人问我是否用过redis了。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>对热点数据进行缓存，比如经常访问的用户资料等。内存价位较高，配合设置过期时间，效果更佳。</p><h4 id="对用户访问某个API进行频率限制"><a href="#对用户访问某个API进行频率限制" class="headerlink" title="对用户访问某个API进行频率限制"></a>对用户访问某个API进行频率限制</h4><p>比起各种分布式协调方案，使用Redis简单多了。</p><h4 id="批量获取key"><a href="#批量获取key" class="headerlink" title="批量获取key"></a>批量获取key</h4><p>当你的Redis运行在大循环中，使用<code>MGET</code>、<code>MSET</code>会有意想不到的效果。这是SQL的Batch模式。</p><h4 id="用户属性存储"><a href="#用户属性存储" class="headerlink" title="用户属性存储"></a>用户属性存储</h4><p>使用大JSON或者<code>HSET</code>、<code>HGET</code>操作HASH，其中，某个属性也可以使用<code>HINCRBY</code>自增哦，牛逼吧。</p><h4 id="实现计数器"><a href="#实现计数器" class="headerlink" title="实现计数器"></a>实现计数器</h4><p>用来实现 用户： 总点赞数，关注数，粉丝数；帖子： 点赞数，评论数，热度；消息： 已读，未读，红点消息数； 话题： 阅读数，帖子数，收藏数<br>使用<code>INCR</code>即可解决。原子的哦。<br>但具体的应用场景亦有它的复杂性<a href="http://blog.csdn.net/heiyeshuwu/article/details/7972050" target="_blank" rel="noopener">[转]微架构设计：微博计数器的设计 http://blog.csdn.net/heiyeshuwu/article/details/7972050</a></p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>通过<code>SETNX</code>来实现锁的获取，通过设置<code>TTL</code>来设置超时时间，通过<code>DEL</code>完成锁的释放。<br>例如：<br>加锁：<code>SETNX foo.lock &lt;current unix time&gt;</code><br>释放锁：<code>DEL foo.lock</code><br>扩展问题：怎么检测死锁，并解决它呢？自己搜索一下吧。</p><h4 id="取最新N个数据的操作"><a href="#取最新N个数据的操作" class="headerlink" title="取最新N个数据的操作"></a>取最新N个数据的操作</h4><p>使用<code>LPUSH</code>插入<br>使用<code>LTRIM</code>让列表只保存前N条</p><h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><p>使用<code>有序的SET</code>，比如，得到前100名高分用户很简单：<code>ZREVRANGE leaderboard 0 99</code><br>同理，可以使用<code>ZREMRANGEBYRANK</code>让有序集合保存前N条<br>例子<a href="http://segmentfault.com/a/1190000002694239" target="_blank" rel="noopener">http://segmentfault.com/a/1190000002694239</a></p><h4 id="用户未读消息列表"><a href="#用户未读消息列表" class="headerlink" title="用户未读消息列表"></a>用户未读消息列表</h4><p>使用<code>SADD</code>、<code>SCARD</code>、<code>DEL</code>等</p><h4 id="黑名单、关注列表、粉丝列表、双向关注列表"><a href="#黑名单、关注列表、粉丝列表、双向关注列表" class="headerlink" title="黑名单、关注列表、粉丝列表、双向关注列表"></a>黑名单、关注列表、粉丝列表、双向关注列表</h4><p>使用<code>ZADD</code>、<code>ZRANK</code>等，将用户的黑名单使用ZADD添加，ZRANK使用返回的sorce值判断是否存在黑名单中</p><h4 id="Uniq操作，获取某段时间所有数据排重值"><a href="#Uniq操作，获取某段时间所有数据排重值" class="headerlink" title="Uniq操作，获取某段时间所有数据排重值"></a>Uniq操作，获取某段时间所有数据排重值</h4><p>这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。更何况有<code>SUNION</code>等合并两个集合的命令。</p><h4 id="用setbit-bitmap-统计每天活跃用户"><a href="#用setbit-bitmap-统计每天活跃用户" class="headerlink" title="用setbit(bitmap)统计每天活跃用户"></a>用setbit(bitmap)统计每天活跃用户</h4><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR以及其它位操作。<br>每一位标识一个用户ID。当某个用户访问我们的网页或执行了某个操作，就在bitmap中把标识此用户的位置为1。<br>使用<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>等。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><code>LPUSH</code>和<code>RPOP</code>命令。<br>如果要实现任务队列，只需要让生产者将任务使用LPUSH命令加入到某个键中，另一边让消费者不断地使用RPOP命令从该键中取出任务即可。<br>RPOP是非阻塞的，如果想要阻塞队列，使用<code>BRPOP</code>，此命令带有超时参数，可得到N个消息。</p><h4 id="Pub、Sub构建实时消息系统"><a href="#Pub、Sub构建实时消息系统" class="headerlink" title="Pub、Sub构建实时消息系统"></a>Pub、Sub构建实时消息系统</h4><p>Redis 的 Pub/Sub 系统可以构建实时的消息系统，比如很多用 Pub/Sub 构建的实时聊天系统的例子</p><h4 id="LBS应用"><a href="#LBS应用" class="headerlink" title="LBS应用"></a>LBS应用</h4><p>Redis3.2将推出GEO功能，将会是除了<code>PostGIS</code>以外有力的开源解决方案。更多功能期待ing…<br>可以实现：</p><ul><li>两个位置之间的距离</li><li>查找附近的人</li><li>摇一摇</li></ul><p>Redis通过组合，可以实现N多功能，如果你有更好的方法，请及时告诉我。</p><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul><li>关于Redis的常识 <a href="http://blog.csdn.net/andy1219111/article/details/18984355" target="_blank" rel="noopener">http://blog.csdn.net/andy1219111/article/details/18984355</a></li><li>Redis GEO 特性简介<a href="http://blog.jobbole.com/89225/" target="_blank" rel="noopener">http://blog.jobbole.com/89225/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;持续更新…&lt;/p&gt;
&lt;p&gt;Redis最近几年很火。笔者很羞愧，很长时间内以为和Memcache一样，只能做缓存。事实上Redis功能丰富，十八般武艺样样具全，几乎适用于互联网行业的各个场景，包括存储。但Redis存储相当的贵，而且大文件不适合这种场景。&lt;br&gt;Redis从设
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="nosql" scheme="http://java.jr-jr.com/tags/nosql/"/>
    
      <category term="redis" scheme="http://java.jr-jr.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>IO NIO的一些概念</title>
    <link href="http://java.jr-jr.com/2015/12/10/io-nio/"/>
    <id>http://java.jr-jr.com/2015/12/10/io-nio/</id>
    <published>2015-12-10T07:05:52.000Z</published>
    <updated>2018-06-06T08:31:42.871Z</updated>
    
    <content type="html"><![CDATA[<div class="tip"><br>NIO，New IO，又叫做Non-blocking IO，Netty线程里用的<code>New I/O worker #*</code><br></div><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>IO 性能对于一个系统的影响是至关重要的。一个系统经过多项优化以后，瓶颈往往落在数据库；而数据库经过多种优化以后，瓶颈最终会落到 IO 。而IO 性能的发展，明显落后于CPU的发展。Redis也好，NoSql也好，这些流行技术的背后都在直接或者间接地回避IO瓶颈，从而提高系统性能。</p><p>我们说阻塞和非阻塞时,要区分场合范围,比如 Linux中说的非阻塞I/O和Java的NIO1.0中的非阻塞I/O不是相同的概念. 从最根本来说, 阻塞就是进程”被”休息,CPU处理其它进程去了.非阻塞可以理解成: 将大的整片时间的阻塞分成N多的小的阻塞,所以进程不断地有机会 “被” CPU光顾, 理论上可以做点其它事.看上去 Linux非阻塞I/O要比阻塞好,但CPU会很大机率﻿因socket没数据﻿而空转.虽然这个进程是爽了, 但是从整个机器的效率来说, 浪费更大了!Java NIO1.0中的非阻塞I/O中的 Selector.select()函数还是阻塞的, 所以不会有无谓的CPU浪费.</p><h4 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h4><p>IO分为两个阶段：</p><ul><li>资源等待阶段</li><li>资源使用阶段</li></ul><p>Java NIO解决的是资源等待阶段阶段的问题。资源使用阶段，依然是在用户线程中去完成的。Java NIO使用的是Reactor模型：<br><img src="/reactor.jpg" alt=""></p><p>Reactor有很多种变种，<a href="http://blog.csdn.net/heyutao007/article/details/45626235" target="_blank" rel="noopener">深入了解</a></p><p>Reactor多线程模型的特点：</p><ul><li>有专门一个NIO线程<code>Acceptor线程</code>用于监听服务端，接收客户端的TCP连接请求；</li><li>网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送；</li><li>1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。</li></ul><h4 id="NIO和BIO的区别"><a href="#NIO和BIO的区别" class="headerlink" title="NIO和BIO的区别"></a>NIO和BIO的区别</h4><ul><li>阻塞IO：使用简单，但随之而来的问题就是会形成阻塞，需要独立线程配合，而这些线程在大多数时候都是没有进行运算的。Java的BIO使用这种方式，问题带来的问题很明显，一个Socket需要一个独立的线程，因此，会造成线程膨胀。</li><li>非阻塞IO：采用轮询方式，不会形成线程的阻塞。Java的NIO使用这种方式，对比BIO的优势很明显，可以使用一个线程进行所有Socket的监听（select）。大大减少了线程数。</li></ul><p>下面我们看一下Linux 5种经典的IO模型。然后我们会发现，Java的NIO，其实只是多路复用而已。</p><h3 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h3><p>linux下有五种常见的IO模型，其中只有一种异步模型，其余皆为同步模型。如图：<br><img src="/io-nio-all.png" alt=""></p><h4 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h4><p>阻塞IO模型是最常见的IO模型了，对于所有的“慢速设备”（<code>socket</code>、<code>pipe</code>、<code>fifo</code>、<code>terminal</code>）的IO默认的方式都是阻塞的方式。阻塞就是进程放弃cpu，让给其他进程使用cpu。进程阻塞最显著的表现就是<code>进程睡眠了</code>。阻塞的时间通常取决于<code>数据</code>是否到来。<br>这种方式使用简单，但随之而来的问题就是会形成阻塞，需要独立线程配合，而这些线程在大多数时候都是没有进行运算的。Java的BIO使用这种方式，问题带来的问题很明显，一个Socket需要一个独立的线程，因此，会<code>造成线程膨胀</code>。<br><img src="/io-nio-block.png" alt=""></p><h4 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h4><p>非阻塞IO就是设置IO相关的系统调用为<code>non-blocking</code>，随后进行的IO操作无论有没有可用数据都会立即返回，并设置errno为<code>EWOULDBLOCK</code>或者<code>EAGAIN</code>。我们可以通过主动check的方式（polling，轮询）确保IO有效时，随之进行相关的IO操作。当然这种方式看起来就似乎不太靠谱，浪费了太多的CPU时间，用宝贵的CPU时间做轮询太不靠谱儿了。图示：<br><img src="/io-nio-nonblocking.png" alt=""></p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>为了解决阻塞I/O的问题,就有了I/O多路复用模型,多路复用就是用<code>单独的线程(是内核级的, 可以认为是高效的优化的)</code> 来统一等待所有的socket上的数据, 一当某个socket上有数据后, 就启用用户线程(可能是从线程池中取出, 而不是重新生成), <code>copy socket data</code>, 并且处理message.因为网络延迟的原因, 同时在处理<code>socket data</code>的用户线程往往比实际的socket数量要少很多. 所以实际应用中, 大部分是用线程池, 池中thread数量可随socket的高峰和低谷 而动态调整.</p><p>多路复用I/O中内核中统一﻿的<code>wait socket data</code>那部分可以理解成是<code>非阻塞</code>, 也可以理解成<code>阻塞</code>. 可以理解成<code>非阻塞</code> 是因为它不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户线程来处理, 理解成<code>阻塞</code>, 是因为它和用户空间(Appliction)层的<code>非阻塞</code>﻿socket的不同是: socket中没有数据时, 内核还是wait(阻塞)的, 而用户空间的非阻塞﻿socket没有数据也会返回, 会造成CPU的浪费.</p><p>Linux下的select和poll 就是多路复用模式,poll相对select,没有了句柄数的限制,但他们都是在内核层通过轮询socket句柄的方式来实现的, 没有利用更底层的notify机制. 但就算是这样,相对阻塞socket也已经﻿进步了很多很多了! 毕竟用一个内核线程就解决了,阻塞socket中N多线程都在无谓地wait的局面.</p><p><div class="tip"><br>多路复用I/O﻿ 还是让用户层来<code>copy socket data</code>. 这个过程是将内核中的<code>socket buffer copy</code>到用户空间的 buffer. 这有两个问题: 一是多了一次内核空间switch到用户空间的过程, 二是用户空间层不便暴露很低层但很高效的copy方式(比如DMA), 所以如果由内核层来做这个动作, 可以更好地提高效率!<br></div><br><img src="/io-nio-muti.png" alt=""></p><h4 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h4><p>所谓信号驱动，就是利用信号机制，安装信号SIGIO的处理函数（进行IO相关操作），通过监控文件描述符，当其就绪时，通知目标进程进行IO操作（signal handler）。<br><img src="/io-nio-signal.png" alt=""></p><h4 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h4><p>由于异步IO请求只是写入了缓存，从缓存到硬盘是否成功不可知，因此异步IO相当于把一个IO拆成了两部分，一是发起请求，二是获取处理结果。因此，对应用来说增加了复杂性。但是异步IO的性能是所有很好的，而且异步的思想贯穿了IT系统放放面面。<br><img src="/io-nio-aio.png" alt=""></p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是Java NIO在linux上的默认实现。相关的工具可以关注<code>select</code>,<code>poll</code>，关于三者间的区别，<a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">参见这里</a>。在Mac上类似的实现是<code>kqueue</code>,Solaris上是<code>/dev/poll</code>。<br>epoll的优点</p><ul><li>支持一个进程打开大数目的socket描述符(FD)</li><li><p>IO效率不随FD数目增加而线性下降</p><blockquote><p>传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。</p></blockquote></li><li><p>使用mmap加速内核与用户空间的消息传递。</p></li><li>内核微调</li></ul><p>epoll有2种工作方式:LT和ET:</p><ul><li>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表．</li><li>ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once),不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。</li></ul><h3 id="Zero-Copy"><a href="#Zero-Copy" class="headerlink" title="Zero Copy"></a>Zero Copy</h3><p>上面多次提到内核空间和用户空间的<code>switch</code>, 在<code>socket read/write</code>这么小的粒度频繁调用, 代价肯定是很大的.<br>所以可以在网上看到<code>Zero Copy</code>的技术, 说到底<code>Zero Copy</code>的思路就是: 分析你的业务, 看看是否能避免不必要的跨空间copy,比如可以用 sendfile()函数充分利用内核可以调用DMA的优势, 直接在内核空间将文件的内容通过socket发送出去,而不必经过用户空间.显然,sendfile是有很多的前提条件的, 如果你想让文件内容作一些变换再发出去,就必须要经过用户空间的<code>Appliation logic</code>, 也是无法使用sendfile了.还有一种方式就是象epoll所做的,用内存映射. 据我所知，kafka速度快的一个原因就是使用了<code>零拷贝</code>。<br>关于零拷贝，可以看<a href="http://my.oschina.net/cloudcoder/blog/299944" target="_blank" rel="noopener">这篇文章</a></p><h3 id="C10K-问题"><a href="#C10K-问题" class="headerlink" title="C10K 问题"></a>C10K 问题</h3><p>网络服务在处理数以万计的客户端连接时,往往出现效率低下甚至完全瘫痪,这被 称为C10K问题。随着互联网的迅速发展,越来越多的网络服务开始面临 C10K 问题, 作为大型网站的开发人员有必要对C10K问题有一定的了解。<br>C10K问题的最大特点是:设计不够良好的程序,其性能和连接数及机器性能的关系往往是非线性的。举个例子:如果没有考虑过C10K问题,一个经典的基于<code>select</code>的程序能在旧服务器上很好处理<code>1000</code>并发的吞吐量,它在2倍性能新服务器上往往处理不了并发<code>2000</code>的吞吐量。<br>这是因为在策略不当时,大量操作的消耗和当前连接数n成线性相关。会导致单个任务的资源消耗和当前连接数的关系会是O(n)。而服务程序需要同时对数以万计的socket进行I/O处理,积累下来的资源消耗会相当可观,这显然会导致系统吞吐量不能 和机器性能匹配。为解决这个问题,必须改变对连接提供服务的策略。<br>更详细的资料参考：<a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">The C10K problem </a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;tip&quot;&gt;&lt;br&gt;NIO，New IO，又叫做Non-blocking IO，Netty线程里用的&lt;code&gt;New I/O worker #*&lt;/code&gt;&lt;br&gt;&lt;/div&gt;

&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;head
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="net" scheme="http://java.jr-jr.com/tags/net/"/>
    
      <category term="io" scheme="http://java.jr-jr.com/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>java内置锁的可重入性</title>
    <link href="http://java.jr-jr.com/2015/12/10/java-reentrant-lock/"/>
    <id>http://java.jr-jr.com/2015/12/10/java-reentrant-lock/</id>
    <published>2015-12-10T06:40:25.000Z</published>
    <updated>2018-06-06T08:31:42.874Z</updated>
    
    <content type="html"><![CDATA[<p><div class="tip"><br>锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等) 。在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。<br></div><br>我们来看看synchronized,它拥有强制原子性的内置锁机制,是一个重入锁,所以在使用synchronized时,当一个线程请求得到一个对象锁后再次请求此对象锁,可以再次得到该对象锁,就是说在一个synchronized方法/块的内部调用本类的其他synchronized方法/块时，是永远可以拿到锁,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        child.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"child.doSomething()"</span>);</span><br><span class="line">        doAnotherThing(); <span class="comment">// 调用自己类中其他的synchronized方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doAnotherThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doSomething(); <span class="comment">// 调用父类的synchronized方法</span></span><br><span class="line">        System.out.println(<span class="string">"child.doAnotherThing()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father.doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">child</span><span class="selector-class">.doSomething</span>()</span><br><span class="line"><span class="selector-tag">father</span><span class="selector-class">.doSomething</span>()</span><br><span class="line"><span class="selector-tag">child</span><span class="selector-class">.doAnotherThing</span>()</span><br></pre></td></tr></table></figure></p><p>这里的对象锁只有一个,就是child对象的锁,当执行child.doSomething时，该线程获得child对象的锁，在doSomething方法内执行doAnotherThing时再次请求child对象的锁，因为synchronized是重入锁，所以可以得到该锁，继续在doAnotherThing里执行父类的doSomething方法时第三次请求child对象的锁，同理可得到，如果不是重入锁的话，那这后面这两次请求锁将会被一直阻塞，从而导致死锁。</p><p>所以在java内部，同一线程在调用自己类中其他synchronized方法/块或调用父类的synchronized方法/块都不会阻碍该线程的执行，就是说同一线程对同一个对象锁是可重入的，而且同一个线程可以获取同一把锁多次，也就是可以多次重入。<strong>因为java线程是基于“每线程（per-thread）”，而不是基于“每调用（per-invocation）”的</strong>（java中线程获得对象锁的操作是以每线程为粒度的，per-invocation互斥体获得对象锁的操作是以每调用作为粒度的）。</p><p>同理，顾名思义，ReentrantLock也是可重入的，如：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getId());</span><br><span class="line"><span class="keyword">set</span>();</span><br><span class="line"><span class="keyword">lock</span>.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getId());</span><br><span class="line"><span class="keyword">lock</span>.unlock();</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">Test ss = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="keyword">new</span> Thread(ss).start();</span><br><span class="line"><span class="keyword">new</span> Thread(ss).start();</span><br><span class="line"><span class="keyword">new</span> Thread(ss).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等) 。在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="初级" scheme="http://java.jr-jr.com/categories/%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="thread" scheme="http://java.jr-jr.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>jstack线程dump输出状态解释</title>
    <link href="http://java.jr-jr.com/2015/12/09/jstack-state/"/>
    <id>http://java.jr-jr.com/2015/12/09/jstack-state/</id>
    <published>2015-12-09T09:17:26.000Z</published>
    <updated>2018-06-06T08:31:42.874Z</updated>
    
    <content type="html"><![CDATA[<p>执行<code>jstack</code>命令，将得到进程的堆栈信息。我一般使用<code>jstack -l pid</code>来得到长列表，显示其详细信息。<br>有时线程挂起的时候，需要执行<code>jstack -F pid</code>来获取。</p><div class="tip"><br>在实际运行中，往往一次 dump的信息，还不足以确认问题。建议产生三次 dump信息，如果每次 dump都指向同一个问题，我们才确定问题的典型性。<br><br>堆栈信息只是一种参考，一些正常RUNNING的线程，由于复杂网络环境和IO的影响，也是有问题的，用jstack就无法定位，需要结合对业务代码的理解。<br></div><h3 id="线程的状态分析"><a href="#线程的状态分析" class="headerlink" title="线程的状态分析"></a>线程的状态分析</h3><p>线程的定义里，有状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        NEW,</span><br><span class="line">        RUNNABLE,</span><br><span class="line">        BLOCKED,</span><br><span class="line">        WAITING,</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">        TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在dump 文件里，写法可能不太一样：</p><ul><li>死锁，Deadlock（重点关注）</li><li>执行中，Runnable   </li><li>等待资源，Waiting on condition（重点关注）</li><li>等待获取监视器，Waiting on monitor entry（重点关注）</li><li>对象等待中，Object.wait() 或 TIMED_WAITING</li><li>暂停，Suspended</li><li>阻塞，Blocked（重点关注）  </li><li>停止，Parked</li></ul><h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><p>线程正在运行中。一般指该线程正在执行状态中，该线程占用了资源，正在处理某个请求，有可能正在传递SQL到数据库执行，有可能在对某个文件操作，有可能进行数据类型等转换。</p><h3 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"t2"</span> prio=<span class="number">6</span> tid=<span class="number">0</span>x02bcf000 nid=<span class="number">0</span>xc70 waiting <span class="keyword">for</span> monitor entry [<span class="number">0</span>x02f6f000]  </span><br><span class="line">   java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: BLOCKED (on <span class="selector-tag">object</span> monitor)  </span><br><span class="line">    at com<span class="selector-class">.demo</span><span class="selector-class">.DeadLock</span>$<span class="number">2</span>.run(DeadLock<span class="selector-class">.java</span>:<span class="number">40</span>)  </span><br><span class="line">    - waiting to lock &lt;<span class="number">0</span>x22a297a8&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.lang</span><span class="selector-class">.Object</span>)  </span><br><span class="line">    - locked &lt;<span class="number">0</span>x22a297b0&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.lang</span><span class="selector-class">.Object</span>)  </span><br><span class="line">   Locked ownable synchronizers:  </span><br><span class="line">    - None    </span><br><span class="line"><span class="string">"t1"</span> prio=<span class="number">6</span> tid=<span class="number">0</span>x02bce400 nid=<span class="number">0</span>xba0 waiting <span class="keyword">for</span> monitor entry [<span class="number">0</span>x02f1f000]  </span><br><span class="line">   java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: BLOCKED (on <span class="selector-tag">object</span> monitor)  </span><br><span class="line">    at com<span class="selector-class">.demo</span><span class="selector-class">.DeadLock</span>$<span class="number">1</span>.run(DeadLock<span class="selector-class">.java</span>:<span class="number">25</span>)  </span><br><span class="line">    - waiting to lock &lt;<span class="number">0</span>x22a297b0&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.lang</span><span class="selector-class">.Object</span>)  </span><br><span class="line">    - locked &lt;<span class="number">0</span>x22a297a8&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.lang</span><span class="selector-class">.Object</span>)  </span><br><span class="line">   Locked ownable synchronizers:  </span><br><span class="line">    - None</span><br></pre></td></tr></table></figure><p>上面是一个典型的死锁堆栈，t1线程lock在地址<code>0x22a297a8</code>，同时t2线程在<code>waiting to lock</code>这个地址。更有意思的是，堆栈也记录了发生死锁的代码行数，这对我们定位问题起到很大的帮助。</p><h3 id="Wait-on-condition"><a href="#Wait-on-condition" class="headerlink" title="Wait on condition"></a>Wait on condition</h3><p><strong>等待资源，或等待某个条件的发生</strong>。具体原因需结合 stacktrace来分析。</p><ul><li><p>常见情况是该线程在 sleep，等待 sleep的时间到了时候，将被唤醒。关键字：<code>TIMED_WAITING</code>,<code>sleeping</code>,<code>parking</code>。TIMED_WAITING可能是调用了有超时参数的wait所引起的。parking指线程处于挂起中。<br>下面是一个典型的sleep引起的<code>Wait on condition</code>。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"thread-1"</span> prio=<span class="number">10</span> tid=<span class="number">0</span>x00007fbe985cd000 nid=<span class="number">0</span>x7bc6 waiting on condition [<span class="number">0</span>x00007fbe65848000]</span><br><span class="line">  java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: TIMED_WAITING (sleeping)</span><br><span class="line">       at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.sleep</span>(Native Method)</span><br><span class="line">       at com<span class="selector-class">.xxx</span><span class="selector-class">.MonitorManager</span>$<span class="number">2</span>.run(MonitorManager<span class="selector-class">.java</span>:<span class="number">124</span>)</span><br><span class="line">       at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.runTask(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">895</span>)</span><br><span class="line">       at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.run(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">918</span>)</span><br><span class="line">       at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">662</span>)</span><br></pre></td></tr></table></figure></li><li><p>如果发现有大量的线程都在处在 Wait on condition，从线程 stack看，正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。一种情况是网络非常忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读 写；另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。可以结合其他网络分析工具定位问题。如下面的堆栈，线程等待在LinkedBlockingQueue上等待数据的生成。</p></li><li>如果堆栈信息明确是应用代码，则证明该线程正在等待资源。一般是大量读取某资源，且该资源采用了资源锁的情况下，线程进入等待状态，等待资源的读取。<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"IoWaitThread"</span> prio=<span class="number">6</span> tid=<span class="number">0</span>x0000000007334800 nid=<span class="number">0</span>x2b3c waiting on condition [<span class="number">0</span>x000000000893f000]</span><br><span class="line">   java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (parking)</span><br><span class="line">        at sun<span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">        - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0</span>x00000007d5c45850&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.AbstractQueuedSynchronizer</span><span class="variable">$ConditionObject</span>)</span><br><span class="line">        at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport<span class="selector-class">.java</span>:<span class="number">156</span>)</span><br><span class="line">        at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.AbstractQueuedSynchronizer</span><span class="variable">$ConditionObject</span>.await(AbstractQueuedSynchronizer<span class="selector-class">.java</span>:<span class="number">1987</span>)</span><br><span class="line">        at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingDeque</span><span class="selector-class">.takeFirst</span>(LinkedBlockingDeque<span class="selector-class">.java</span>:<span class="number">440</span>)</span><br><span class="line">        at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingDeque</span><span class="selector-class">.take</span>(LinkedBlockingDeque<span class="selector-class">.java</span>:<span class="number">629</span>)</span><br><span class="line">        at com<span class="selector-class">.xxx</span><span class="selector-class">.ThreadIoWaitState</span><span class="variable">$IoWaitHandler2</span>.run(ThreadIoWaitState<span class="selector-class">.java</span>:<span class="number">89</span>)</span><br><span class="line">        at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">662</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Waiting-on-monitor-entry和Object-wait"><a href="#Waiting-on-monitor-entry和Object-wait" class="headerlink" title="Waiting on monitor entry和Object.wait()"></a>Waiting on monitor entry和Object.wait()</h3><p><strong>意味着线程在等待进入一个临界区</strong><br>Monitor是 Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class的锁。每一个对象都有，也仅有一个 monitor。<br><img src="/java-entry-set-wait-set.png" alt=""></p><ul><li>所有期待获得锁的线程，在锁已经被其它线程拥有的时候，这些期待获得锁的线程就进入了<code>Object Lock</code>的<code>entry set</code>区域。</li><li>所有曾经获得过锁，但是由于其它必要条件不满足而需要wait的时候，线程就进入了<code>Object Lock</code>的<code>wait set</code>区域 。</li><li>在<code>wait set</code>区域的线程获得<code>notify/notifyAll</code>通知的时候，随机的一个Thread（notify）或者是全部的Thread（notifyALL）从Object Lock的wait set区域进入了entry set中。</li><li>在当前拥有锁的线程释放掉锁的时候，处于该<code>Object Lock</code>的<code>entryset</code>区域的线程都会抢占该锁，但是只能有任意的一个Thread能取得该锁，而其他线程依然在<code>entry set</code>中等待下次来抢占到锁之后再执行。</li></ul><p>看下面的堆栈，线程在等待数据库连接池返回一个可用的链接<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" DB-Processor-13"</span> daemon prio=<span class="number">5</span> tid=<span class="number">0</span>x003edf98 nid=<span class="number">0</span>xca waiting <span class="keyword">for</span> monitor entry [<span class="number">0</span>x000000000825f000]</span><br><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: BLOCKED (on <span class="selector-tag">object</span> monitor)</span><br><span class="line">       at beans<span class="selector-class">.ConnectionPool</span><span class="selector-class">.getConnection</span>(ConnectionPool<span class="selector-class">.java</span>:<span class="number">102</span>)</span><br><span class="line">       - waiting to lock &lt;<span class="number">0</span>xe0375410&gt; (<span class="selector-tag">a</span> beans.ConnectionPool)</span><br><span class="line">       at xxx.getTodayCount(ServiceCnt<span class="selector-class">.java</span>:<span class="number">111</span>)</span><br><span class="line">       at xxx<span class="selector-class">.ServiceCnt</span><span class="selector-class">.insertCount</span>(ServiceCnt<span class="selector-class">.java</span>:<span class="number">43</span>)</span><br><span class="line"><span class="string">"DB-Processor-14"</span> daemon prio=<span class="number">5</span> tid=<span class="number">0</span>x003edf98 nid=<span class="number">0</span>xca waiting <span class="keyword">for</span> monitor entry [<span class="number">0</span>x000000000825f020]</span><br><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: BLOCKED (on <span class="selector-tag">object</span> monitor)</span><br><span class="line">       at beans<span class="selector-class">.ConnectionPool</span><span class="selector-class">.getConnection</span>(ConnectionPool<span class="selector-class">.java</span>:<span class="number">102</span>)</span><br><span class="line">       - waiting to lock &lt;<span class="number">0</span>xe0375410&gt; (<span class="selector-tag">a</span> beans.ConnectionPool)</span><br><span class="line">       at xxx<span class="selector-class">.ServiceCnt</span><span class="selector-class">.getTodayCount</span>(ServiceCnt<span class="selector-class">.java</span>:<span class="number">111</span>)</span><br><span class="line">       at xxx<span class="selector-class">.ServiceCnt</span><span class="selector-class">.insertCount</span>(ServiceCnt<span class="selector-class">.java</span>:<span class="number">43</span>)</span><br><span class="line"><span class="string">" DB-Processor-3"</span> daemon prio=<span class="number">5</span> tid=<span class="number">0</span>x00928248 nid=<span class="number">0</span>x8b waiting <span class="keyword">for</span> monitor entry [<span class="number">0</span>x000000000825d080]</span><br><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: RUNNABLE</span><br><span class="line">       at oracle<span class="selector-class">.jdbc</span><span class="selector-class">.driver</span><span class="selector-class">.OracleConnection</span><span class="selector-class">.isClosed</span>(OracleConnection<span class="selector-class">.java</span>:<span class="number">570</span>)</span><br><span class="line">       - waiting to lock &lt;<span class="number">0</span>xe03ba2e0&gt; (<span class="selector-tag">a</span> oracle<span class="selector-class">.jdbc</span><span class="selector-class">.driver</span><span class="selector-class">.OracleConnection</span>)</span><br><span class="line">       at beans<span class="selector-class">.ConnectionPool</span><span class="selector-class">.getConnection</span>(ConnectionPool<span class="selector-class">.java</span>:<span class="number">112</span>)</span><br><span class="line">       - locked &lt;<span class="number">0</span>xe0386580&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.util</span><span class="selector-class">.Vector</span>)</span><br><span class="line">       - locked &lt;<span class="number">0</span>xe0375410&gt; (<span class="selector-tag">a</span> beans.ConnectionPool)</span><br><span class="line">       at xxx<span class="selector-class">.Cue_1700c</span><span class="selector-class">.GetNationList</span>(Cue_1700c<span class="selector-class">.java</span>:<span class="number">66</span>)</span><br><span class="line">       at org<span class="selector-class">.apache</span><span class="selector-class">.jsp</span><span class="selector-class">.cue_1700c_jsp</span>._jspService(cue_1700c_jsp<span class="selector-class">.java</span>:<span class="number">120</span>)</span><br></pre></td></tr></table></figure></p><h3 id="Blocked"><a href="#Blocked" class="headerlink" title="Blocked"></a>Blocked</h3><p>线程阻塞，是指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器标识为阻塞状态，可以理解为等待资源超时的线程。<br>如果线程处于Blocked状态，但是原因不清楚。可以使用<code>jstack -m pid</code>得到线程的mixed信息。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----------------- t@<span class="number">13</span> -----------------</span><br><span class="line"><span class="number">0xff31e8b8</span>      ___lwp_cond_wait + <span class="number">0x4</span></span><br><span class="line"><span class="number">0xfea8c810</span>      <span class="literal">void</span> ObjectMonitor<span class="type">::EnterI</span>(<span class="keyword">Thread</span>*) + <span class="number">0x2b8</span></span><br><span class="line"><span class="number">0xfeac86b8</span>      <span class="literal">void</span> ObjectMonitor<span class="type">::enter2</span>(<span class="keyword">Thread</span>*) + <span class="number">0x250</span></span><br></pre></td></tr></table></figure></p><p>例如，以上信息表明，线程在尝试进入同步块时阻塞了。</p><h3 id="关于concurrent的Lock"><a href="#关于concurrent的Lock" class="headerlink" title="关于concurrent的Lock"></a>关于concurrent的Lock</h3><p>在JDK 5.0中，引入了<code>Lock</code>机制，从而使开发者能更灵活的开发高性能的并发多线程程序，可以替代以往JDK中的<code>synchronized</code>和<code>Monitor</code>的机制。但是，要注意的是，因为Lock类只是一个普通类，JVM无从得知Lock对象的占用情况，所以在线程DUMP中，也不会包含关于 Lock的信息，关于死锁等问题，就不如用 synchronized的编程方式容易识别。</p><h3 id="jstack解决CPU过高的问题"><a href="#jstack解决CPU过高的问题" class="headerlink" title="jstack解决CPU过高的问题"></a>jstack解决CPU过高的问题</h3><blockquote><p>第一步，找到占用cpu最高的一个线程<br>方法一：<code>top -p [pid]</code><br>方法二：<code>ps -mo spid,lwp,stime,time,%cpu -p [pid]</code><br>方法三：直接<code>top</code>,然后<code>shift+h</code><br>第二步，将其转化成16进制。假使我们得到的线程号为n，接下来将它转成16进制，记为spid<br>方法一：<code>echo &quot;obase=64;n&quot;|bc</code><br>方法二：<code>printf 0x%x n</code><br>下一步，执行<code>jstack -l  pid| grep spid -A 100</code> 打印后面100行分析问题</p></blockquote><p>下面便是一个查找的结果<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"http-8081-11"</span> daemon prio=<span class="number">10</span> tid=<span class="number">0</span>x00002aab049a1800 nid=<span class="number">0</span>x52f1 <span class="keyword">in</span> Object.wait() [<span class="number">0</span>x0000000042c75000]  </span><br><span class="line">   java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (on <span class="selector-tag">object</span> monitor)  </span><br><span class="line">     at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span><span class="selector-class">.wait</span>(Native Method)  </span><br><span class="line">     at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span><span class="selector-class">.wait</span>(Object<span class="selector-class">.java</span>:<span class="number">485</span>)  </span><br><span class="line">     at org<span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.net</span><span class="selector-class">.JIoEndpoint</span><span class="variable">$Worker</span>.await(JIoEndpoint<span class="selector-class">.java</span>:<span class="number">416</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;执行&lt;code&gt;jstack&lt;/code&gt;命令，将得到进程的堆栈信息。我一般使用&lt;code&gt;jstack -l pid&lt;/code&gt;来得到长列表，显示其详细信息。&lt;br&gt;有时线程挂起的时候，需要执行&lt;code&gt;jstack -F pid&lt;/code&gt;来获取。&lt;/p&gt;
&lt;di
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="tools" scheme="http://java.jr-jr.com/tags/tools/"/>
    
      <category term="shell" scheme="http://java.jr-jr.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>TIME_WAIT和CLOSE_WAIT解惑</title>
    <link href="http://java.jr-jr.com/2015/12/07/close-wait-time-wait/"/>
    <id>http://java.jr-jr.com/2015/12/07/close-wait-time-wait/</id>
    <published>2015-12-07T14:57:39.000Z</published>
    <updated>2018-06-06T08:31:42.868Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络状态的获取"><a href="#网络状态的获取" class="headerlink" title="网络状态的获取"></a>网络状态的获取</h4><p>Java程序员大多数要与各种网络状态打交道，来处理各种高并发情况下发生的奇怪的问题。其中，TIME_WAIT和CLOSE_WAIT状态是经常碰到问题的状态。但我发现在实际工作中，很少人能定位到此类问题的真正原因。相对于TIME_WAIT，CLOSE_WAIT状态的出现更有可能是程序的BUG引起的。TIME_WAIT的问题需要调整系统参数，但CLOSE_WAIT的出现需要定位代码。</p><p>如下代码可以看到系统处于各种网络状态的状态数量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk <span class="string">'/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;'</span></span><br></pre></td></tr></table></figure></p><p>可能会得到以下结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TIME_WAIT 18140</span><br><span class="line">CLOSE_WAIT 2882</span><br><span class="line">FIN_WAIT1 1</span><br><span class="line">ESTABLISHED 19829</span><br><span class="line">SYN_RECV 2</span><br><span class="line">LAST_ACK 1</span><br></pre></td></tr></table></figure></p><p>关于系统状态的含义，请参见<a href="/2015/12/07/tcp-ip-state/">TCP/IP状态含义</a>，我们这里只关注TIME_WAIT和CLOSE_WAIT，<strong>TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关</strong>。</p><p>Linux的文件句柄是有限的，如果一些状态保持着不消失，将逐渐的耗尽句柄资源，新的连接将直接拒绝，造成异常。</p><h4 id="系统保持了大量的CLOSE-WAIT状态"><a href="#系统保持了大量的CLOSE-WAIT状态" class="headerlink" title="系统保持了大量的CLOSE_WAIT状态"></a>系统保持了大量的CLOSE_WAIT状态</h4><p>把CLOSE_WAIT放在前面的原因是，出现此状态的原因很可能是程序有问题，根本问题还是程序写的不好，有待提高。<br><img src="/tcp_close.gif" alt=""></p><p>从上面的图可以看出来，如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在<strong>对方关闭连接之后服务器程序自己没有进一步发出ack信号</strong>。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。</p><p>拿HttpClient来说，<a href="http://blog.csdn.net/shootyou/article/details/6615051" target="_blank" rel="noopener">更详细的分析</a>：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">client = HttpConnectionManager.getHttpClient();</span><br><span class="line">HttpGet <span class="keyword">get</span> = <span class="keyword">new</span> <span class="type">HttpGet</span>();</span><br><span class="line"><span class="keyword">get</span>.setURI(<span class="keyword">new</span> <span class="type">URI</span>(urlPath));</span><br><span class="line">HttpResponse response = client.execute(<span class="keyword">get</span>);</span><br><span class="line"><span class="keyword">if</span> (response.getStatusLine ().getStatusCode () != <span class="number">200</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">HttpEntity entity =response.getEntity();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( entity != <span class="literal">null</span> )&#123;</span><br><span class="line"><span class="keyword">in</span> = entity.getContent();</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString ();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"><span class="keyword">if</span> (isr != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">isr.close ();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace (); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">in</span> != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">in</span>.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace (); &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HttpClient使用我们常用的<code>InputStream.close()</code>来确认连接关闭，分析上面的代码，一旦出现<code>非200</code>的连接，这个连接将永远僵死在连接池里头，因为inputStream得不到初始化，永远不会调用close()方法了。<br>正确方法是调用<code>HttpGet</code>的<code>abort()</code>方法来终止连接。</p><p><div class="tip">一句话，出现了大量CLOSE_WAIT状态，检查下你的代码。</div></p><h4 id="系统保持了大量的TIME-WAIT状态"><a href="#系统保持了大量的TIME-WAIT状态" class="headerlink" title="系统保持了大量的TIME_WAIT状态"></a>系统保持了大量的TIME_WAIT状态</h4><p>上面说到TIME_WAIT是主动关闭。什么叫主动关闭呢？就是假如我们建立了一个链接，读取完数据之后，就会发起主动关闭连接。进入TIME_WAIT的状态，然后在保持这个状态2MSL（<code>max segment lifetime</code>）。MSL的值在一般的实现中取30s，有些实现采用2分钟。为什么还要等上一段时间呢？虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文，并保证于此。</p><blockquote><p>TCP下每条连接都有一个属性叫做max segment lifetime，就是说该连接关闭后，要经过2*max segment lifetime的时间，才算是真正的被关闭，才能被重新建立，以防止这条链路上还有东西在传输。</p></blockquote><p>这种情况一般发生在频繁开启和关闭连接的应用中。比如：</p><ul><li>使用反向代理Nginx</li><li>有类似爬虫的程序在频繁开启关闭连接</li><li>某些频繁读写的WEB服务器</li><li>短时间内接受大量请求或者受到攻击</li></ul><p>解决方式：<br>修改<code>/etc/sysctl.conf</code>文件：<br>在这个文件中，加入下面的几行内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"> <span class="comment">#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"> <span class="comment">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line"> <span class="comment">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 5</span><br><span class="line"> <span class="comment">#修改系统默认的 TIMEOUT 时间;</span></span><br></pre></td></tr></table></figure></p><p>此外，如果你的连接数本身就很多，我们可以再优化一下<code>TCP/IP</code>的可使用端口范围，进一步提升服务器的并发能力。依然是往上面的参数文件中，加入下面这些配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"> <span class="comment">#当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</span></span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line"> <span class="comment">#用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。(注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！)</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8192</span><br><span class="line"> <span class="comment">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line"> <span class="comment">#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。</span></span><br><span class="line"> <span class="comment">#对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。</span></span><br><span class="line"> <span class="comment">#此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。</span></span><br></pre></td></tr></table></figure></p><p>这几个参数，建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置这几个参数。</p><p>运行 <code>/sbin/sysctl -p</code> 使配置生效.</p><p>扩展阅读<br><a href="http://blog.miniasp.com/post/2010/11/17/How-to-deal-with-TIME_WAIT-problem-under-Windows.aspx" target="_blank" rel="noopener">在 Windows 上遇到非常多 TIME_WAIT 連線時應如何處理</a><br><a href="http://blog.csdn.net/chinalinuxzend/article/details/1792184" target="_blank" rel="noopener">linux服务器历险之sysctl优化linux网络</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;网络状态的获取&quot;&gt;&lt;a href=&quot;#网络状态的获取&quot; class=&quot;headerlink&quot; title=&quot;网络状态的获取&quot;&gt;&lt;/a&gt;网络状态的获取&lt;/h4&gt;&lt;p&gt;Java程序员大多数要与各种网络状态打交道，来处理各种高并发情况下发生的奇怪的问题。其中，TIME_
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="net" scheme="http://java.jr-jr.com/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP的各种状态</title>
    <link href="http://java.jr-jr.com/2015/12/07/tcp-ip-state/"/>
    <id>http://java.jr-jr.com/2015/12/07/tcp-ip-state/</id>
    <published>2015-12-07T10:31:06.000Z</published>
    <updated>2018-06-06T08:31:42.884Z</updated>
    
    <content type="html"><![CDATA[<p>TCP是一种复杂的协议。其中，状态的转变是个需要理解的脑力活，其状态转变图如下，我们将逐一说明这些状态的意义，其中TIME_WAIT和CLOSE_WAIT是经常考察的状态，Linux下使用netstat可以看到这些状态：<br><img src="/tcp-ip-state.png" alt=""></p><h4 id="CLOSED"><a href="#CLOSED" class="headerlink" title="CLOSED"></a>CLOSED</h4><p>这个没什么好说的了，表示初始状态。</p><h4 id="LISTEN"><a href="#LISTEN" class="headerlink" title="LISTEN"></a>LISTEN</h4><p>这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。</p><h4 id="SYN-RCVD"><a href="#SYN-RCVD" class="headerlink" title="SYN_RCVD"></a>SYN_RCVD</h4><p>这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。</p><h4 id="SYN-SENT"><a href="#SYN-SENT" class="headerlink" title="SYN_SENT"></a>SYN_SENT</h4><p>这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</p><h4 id="ESTABLISHED"><a href="#ESTABLISHED" class="headerlink" title="ESTABLISHED"></a>ESTABLISHED</h4><p>这个容易理解了，表示连接已经建立了。</p><h4 id="FIN-WAIT-1"><a href="#FIN-WAIT-1" class="headerlink" title="FIN_WAIT_1"></a>FIN_WAIT_1</h4><p>这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。</p><h4 id="FIN-WAIT-2"><a href="#FIN-WAIT-2" class="headerlink" title="FIN_WAIT_2"></a>FIN_WAIT_2</h4><p>上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。</p><h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p>表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p><h4 id="CLOSING"><a href="#CLOSING" class="headerlink" title="CLOSING"></a>CLOSING</h4><p>这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p><h4 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h4><p>这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。<br>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP是一种复杂的协议。其中，状态的转变是个需要理解的脑力活，其状态转变图如下，我们将逐一说明这些状态的意义，其中TIME_WAIT和CLOSE_WAIT是经常考察的状态，Linux下使用netstat可以看到这些状态：&lt;br&gt;&lt;img src=&quot;/tcp-ip-state
      
    
    </summary>
    
      <category term="初级" scheme="http://java.jr-jr.com/categories/%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="net" scheme="http://java.jr-jr.com/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>java 为什么wait(),notify(),notifyAll()必须在同步方法/代码块中调用？</title>
    <link href="http://java.jr-jr.com/2015/12/05/java-wait-notify-sync/"/>
    <id>http://java.jr-jr.com/2015/12/05/java-wait-notify-sync/</id>
    <published>2015-12-05T09:29:10.000Z</published>
    <updated>2018-06-06T08:31:42.874Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，所有对象都能够被作为”监视器<code>monitor</code>“——指一个拥有<code>一个独占锁</code>，<code>一个入口队列</code>和<code>一个等待队列</code>的实体entity。所有对象的非同步方法都能够在任意时刻被任意线程调用，此时不需要考虑加锁的问题。而对于对象的同步方法来说，在任意时刻有且仅有一个拥有该对象独占锁的线程能够调用它们。例如，一个同步方法是独占的。如果在线程调用某一对象的同步方法时，对象的独占锁被其他线程拥有，那么当前线程将处于阻塞状态，并添加到对象的入口队列中。</p><p>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。这一点通常不会被程序员注意，因为程序验证通常是在对象的同步方法或同步代码块中调用它们的。如果尝试在未获取对象锁时调用这三个方法，那么你将得到一个<code>java.lang.IllegalMonitorStateException:current thread not owner</code>。</p><p>当一个线程正在某一个对象的同步方法中运行时调用了这个对象的wait方法，那么这个线程将释放该对象的独占锁并被放入这个对象的等待队列。注意，wait()方法强制当前线程释放对象锁。这意味着<strong>在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。</strong>因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。</p><p>当某线程调用某对象的notify()或notifyAll()方法时，任意一个(对于notify())或者所有(对于notifyAll())在该对象的等待队列中的线程，将被转移到该对象的入口队列。接着这些队列将竞争该对象的锁，最终获得锁的线程继续执行。如果没有线程在该对象的等待队列中等待获得锁，那么notify()和notifyAll()将不起任何作用。<strong>在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。</strong>因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。</p><p>对于处于某对象的等待队列中的线程，只有当其他线程调用此对象的notify()或notifyAll()方法时才有机会继续执行。</p><p>调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:”特殊状态已经被设置”。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。</p><p>例如，生产者线程向缓冲区中写入数据，消费者线程从缓冲区中读取数据。消费者线程需要等待直到生产者线程完成一次写入操作。生产者线程需要等待消费者线程完成一次读取操作。假设wait(),notify(),notifyAll()方法不需要加锁就能够被调用。此时消费者线程调用wait()正在进入状态变量的等待队列(译者注:可能还未进入)。在同一时刻，生产者线程调用notify()方法打算向消费者线程通知状态改变。那么此时消费者线程将错过这个通知并一直阻塞。因此，对象的wait(),notify(),notifyAll()方法必须在该对象的同步方法或同步代码块中被互斥地调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Java中，所有对象都能够被作为”监视器&lt;code&gt;monitor&lt;/code&gt;“——指一个拥有&lt;code&gt;一个独占锁&lt;/code&gt;，&lt;code&gt;一个入口队列&lt;/code&gt;和&lt;code&gt;一个等待队列&lt;/code&gt;的实体entity。所有对象的非同步方法都能够在任意时刻被任
      
    
    </summary>
    
      <category term="初级" scheme="http://java.jr-jr.com/categories/%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="thread" scheme="http://java.jr-jr.com/tags/thread/"/>
    
      <category term="object" scheme="http://java.jr-jr.com/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(Design Pattern)</title>
    <link href="http://java.jr-jr.com/2015/12/05/design-pattern/"/>
    <id>http://java.jr-jr.com/2015/12/05/design-pattern/</id>
    <published>2015-12-05T08:38:58.000Z</published>
    <updated>2018-06-06T08:31:42.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>Simple Factory，是由一个工厂对象决定创建出哪一种产品类的实例，是工厂模式家族中最简单实用的模式。</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>Factory Method，定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。为了遵循扩展开放，修改关闭原则，将简单工厂类转换为工厂方法接口，将其Switch分支分离成子类去继承工厂方法接口类，顺利的将创建对象的过程延迟到子类。</p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>Abstract Factory，提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。</p><h3 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h3><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h3 id="建造者（Builder）"><a href="#建造者（Builder）" class="headerlink" title="建造者（Builder）"></a>建造者（Builder）</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h3 id="单例（Singleton"><a href="#单例（Singleton" class="headerlink" title="单例（Singleton)"></a>单例（Singleton)</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>将一个类的接口转换为客户希望的另一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类一起工作。</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>为其他对象提供一种代理以控制对这个对象的访问。</p><h3 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h3><p>将对象组合成树形结构以表示“部分——整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><h3 id="flyweight"><a href="#flyweight" class="headerlink" title="flyweight"></a>flyweight</h3><p>运用共享技术有效的支持大量细粒度的对象。</p><h3 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h3><p>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><h3 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h3><p>动态的给一个对象添加额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p><h3 id="Memento"><a href="#Memento" class="headerlink" title="Memento"></a>Memento</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态</p><h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p><h3 id="策略（Strategy）"><a href="#策略（Strategy）" class="headerlink" title="策略（Strategy）"></a>策略（Strategy）</h3><p>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p><h3 id="模板方法（TemplateMethod）"><a href="#模板方法（TemplateMethod）" class="headerlink" title="模板方法（TemplateMethod）"></a>模板方法（TemplateMethod）</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h3 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h3><p>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><h3 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h3><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><h3 id="职责链（Chain-of-Responsibility"><a href="#职责链（Chain-of-Responsibility" class="headerlink" title="职责链（Chain of Responsibility)"></a>职责链（Chain of Responsibility)</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，知道有一个对处理它为止。</p><h3 id="中介者-Mediator"><a href="#中介者-Mediator" class="headerlink" title="中介者(Mediator)"></a>中介者(Mediator)</h3><p>用一个中介者对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的关系</p><h3 id="状态-State"><a href="#状态-State" class="headerlink" title="状态(State)"></a>状态(State)</h3><p>当一个对象内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p><h3 id="访问者（Visitor）"><a href="#访问者（Visitor）" class="headerlink" title="访问者（Visitor）"></a>访问者（Visitor）</h3><p>表示一个作用于某对象结构中的个元素的操作。它使你可以在不改变各元素的类的前提下定义作用与这些元素的新操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; class=&quot;headerlink&quot; title=&quot;简单工厂&quot;&gt;&lt;/a&gt;简单工厂&lt;/h3&gt;&lt;p&gt;Simple Factory，是由一个工厂对象决定创建出哪一种产品类的实例，是工厂模式家族中最简单实用的模式。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="arch" scheme="http://java.jr-jr.com/tags/arch/"/>
    
  </entry>
  
  <entry>
    <title>interrupt、interrupted 、isInterrupted 区别</title>
    <link href="http://java.jr-jr.com/2015/12/04/interrupt/"/>
    <id>http://java.jr-jr.com/2015/12/04/interrupt/</id>
    <published>2015-12-04T09:04:39.000Z</published>
    <updated>2018-06-06T08:31:42.871Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://m.oschina.net/blog/121933" target="_blank" rel="noopener">个人认为这个介绍很不错,转了</a></p><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p><code>interrupt</code>方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出<code>interruptedException</code>的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p><h3 id="interrupted-和-isInterrupted"><a href="#interrupted-和-isInterrupted" class="headerlink" title="interrupted 和 isInterrupted"></a>interrupted 和 isInterrupted</h3><p>首先看一下该方法的实现：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">interrupted</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法就是直接调用当前线程的<code>isInterrupted(true)</code>方法。<br>然后再来看一下 isInterrupted的实现：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">return</span> <span class="title">isInterrupted</span><span class="params">( <span class="keyword">false</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两个方法有两个主要区别：</p><ul><li><p>interrupted 是作用于当前线程，isInterrupted 是作用于调用该方法的线程对象所对应的线程。（线程对象对应的线程不一定是当前运行的线程。例如我们可以在A线程中去调用B线程对象的isInterrupted方法。）<br>这两个方法最终都会调用同一个方法，只不过参数一个是true，一个是false；</p></li><li><p>第二个区别主要体现在调用的方法的参数上，让我们来看一看这个参数是什么含义<br>先来看一看被调用的方法 <code>isInterrupted(boolean arg)</code>的定义：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">( <span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>原来这是一个本地方法，看不到源码。不过没关系，通过参数名我们就能知道，这个参数代表是否要清除状态位。<br>如果这个参数为true，说明返回线程的状态位后，要清掉原来的状态位（恢复成原来情况）。这个参数为false，就是直接返回线程的状态位。</p><p>这两个方法很好区分，<strong>只有当前线程才能清除自己的中断位</strong>（对应interrupted（）方法）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://m.oschina.net/blog/121933&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人认为这个介绍很不错,转了&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;interrupt&quot;&gt;&lt;a href=&quot;#interrupt&quot; 
      
    
    </summary>
    
      <category term="中级" scheme="http://java.jr-jr.com/categories/%E4%B8%AD%E7%BA%A7/"/>
    
    
      <category term="thread" scheme="http://java.jr-jr.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Java的上下文切换</title>
    <link href="http://java.jr-jr.com/2015/12/04/context-switch/"/>
    <id>http://java.jr-jr.com/2015/12/04/context-switch/</id>
    <published>2015-12-04T04:20:29.000Z</published>
    <updated>2018-06-06T08:31:42.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么叫上下文切换"><a href="#什么叫上下文切换" class="headerlink" title="什么叫上下文切换"></a>什么叫上下文切换</h3><p><a href="http://www.linfo.org/context_switch.html" target="_blank" rel="noopener">Context Switch Definition</a><br>上下文切换只能发生在内核态中<br>简单点说：<br>上下文切换是指CPU从一个进程或线程切换到另一个进程或线程。<br>上下文是指某一时间点CPU<code>寄存器</code>和<code>程序计数器</code>的内容。<br>CPU给每个任务都服务一定的时间, 然后把当前任务的状态保存下来, 在加载下一任务的状态后, 继续服务下一任务. <code>任务的状态保存及再加载, 这段过程就叫做上下文切换</code>. 时间片轮转的方式使多个任务在同一颗CPU上执行变成了可能, 但同时也带来了保存现场和加载现场的直接消耗.</p><h3 id="什么时候发生上下文切换"><a href="#什么时候发生上下文切换" class="headerlink" title="什么时候发生上下文切换"></a>什么时候发生上下文切换</h3><ul><li>当前执行任务的时间片用完, 系统CPU正常执行下一个任务</li><li>当前执行任务碰到IO阻塞, 调度器将挂起此任务</li><li>多个任务抢占锁资源, 当前任务没有抢到,被调度器挂起</li><li>用户代码挂起当前任务, 让出CPU时间，如调用wait()</li><li>硬件中断</li></ul><h3 id="上下文切换的消耗"><a href="#上下文切换的消耗" class="headerlink" title="上下文切换的消耗"></a>上下文切换的消耗</h3><p>多线程并不一定会比单线程快，主要由以下因素影响：<br><strong>直接消耗</strong>(Linux线程不需要切换页表、刷新TLB)</p><ul><li>CPU寄存器需要保存和加载</li><li>操作系统调度器执行耗时</li><li>TLB实例需要重新加载 <a href="http://blog.csdn.net/kickxxx/article/details/8736293" target="_blank" rel="noopener">(Linux kernel和TLB)</a></li><li>CPU 的pipeline需要刷掉</li></ul><p><strong>间接消耗</strong></p><ul><li>多核的cache之间得共享数据</li></ul><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的CPU时间，事实上，可能是操作系统中时间消耗最大的操作。</p><div class="tip">Linux没有线程的概念，只是为了迎合开发者的需要而使用了一个所谓轻量级进程（POSIX线程），你从这两者区别也可以发现，轻量级进程最大的用途在于可以共享一些资源，如地址空间，打开文件。所以，事实上Linux实现多线程应用程序的方式就是用轻量级进程来代替线程。</div><p>使用<code>vmstat</code>可以看到上下文切换消耗(<code>cs</code>)<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">0</span>  <span class="number">0</span>  <span class="number">74956</span> <span class="number">2952620</span> <span class="number">570032</span> <span class="number">57981312</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span> <span class="number">2190</span>  <span class="number">414</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么叫上下文切换&quot;&gt;&lt;a href=&quot;#什么叫上下文切换&quot; class=&quot;headerlink&quot; title=&quot;什么叫上下文切换&quot;&gt;&lt;/a&gt;什么叫上下文切换&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.linfo.org/context_switch.h
      
    
    </summary>
    
      <category term="初级" scheme="http://java.jr-jr.com/categories/%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="thread" scheme="http://java.jr-jr.com/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>调度系统，Crontab的格式</title>
    <link href="http://java.jr-jr.com/2015/12/03/crontab/"/>
    <id>http://java.jr-jr.com/2015/12/03/crontab/</id>
    <published>2015-12-03T10:38:36.000Z</published>
    <updated>2018-06-06T08:31:42.869Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>定时器大家都会用到，但JDK的Timer和ScheduledThreadPoolExecutor都只是提供固定频率的定时功能，很难满足业务需求。或多或少的，你肯定用过Linux的crontab和Java的Quartz。</p><p>Crontab的缺点是显而易见的，它是单机的，机器一旦宕了，一切都完蛋了。它的好处就是使用简单，可使用简单的脚本进行任务编写。</p><p>针对定时器的问题，一般集中在以下几个：</p><ul><li>Quartz怎么做分布式调度</li><li>Quartz分布式，偶尔重复执行的问题</li><li>Quartz的表达式是怎么表示的</li><li>有没有自己实现过调度系统，还有没有其他思路</li></ul><p>Quartz使用分布式方式部署，需要每台服务器的<code>时钟相同</code>，最好是使用统一的ntp服务。多机部署的情况下，要保证每个时刻只有一台机器运行任务（比如一些退款服务，肯定不能多次执行），需要做一些分布式协调。最笨的方式就是使用Quartz自带的分布式方案，使用数据库锁进行任务选择；如果不想使用数据库环境，可以使用zookeeper或者redis分布式锁进行协调控制。需要注意的是，任何协调都不是100%准确的，业务方必须要做好任务多次执行的防重。</p><p>造成任务协调失败的情况很多，其中之一就是服务期间的时钟不同步，执行的步伐乱七八糟的，难受。另一种情况就是你的任务执行效率太高了，几毫秒就完成了，某台机器将任务执行完了进行回馈，于是另一台判断任务还没执行，继续领取任务，当然这是偶发情况。</p><p>调度系统一种思路是分布式的推，类似Quartz，每台服务器都在进行计算，触发，计算的轮回，通过远程调用进行触发。如果我想知道任务的执行进度，间或想提供一种更nice的配置方式给客户端，可以提供定制的jar包给业务方，业务方会定期的拉取（或者zk的通知）任务列表，进行相应的触发，同时提供汇报进度接口。</p><p>拉取任务的方式更加灵活，但比较复杂，尤其是在异构环境下，需要提供多种语言的客户端解决方案。在大多数情况下，Quartz就能够满足。</p><h3 id="Linux-Crontab格式"><a href="#Linux-Crontab格式" class="headerlink" title="Linux Crontab格式"></a>Linux Crontab格式</h3><blockquote><p>一个cron表达式有至少5个有空格分隔的时间元素。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------- 分 (0 - 59)</span><br><span class="line">|  +------------- 时 (0 - 23)</span><br><span class="line">|  |  +---------- 日 (1 - 31)</span><br><span class="line">|  |  |  +------- 月 (1 - 12)</span><br><span class="line">|  |  |  |  +---- 周 (0 - 7) (Sunday=0 or 7)</span><br><span class="line">|  |  |  |  |</span><br><span class="line">*  *  *  *  *  <span class="built_in">command</span> to be executed</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>逗号(‘,’) 指定列表值。如: “1,3,4,7,8”</li><li>中横线(‘-‘) 指定范围值 如 “1-6”, 代表 “1,2,3,4,5,6”</li><li>星号 (‘*’) 代表所有可能的值</li><li>Linux(开源系统似乎都可以)下还有个 “/“ 可以用. 在 Minute 字段上，*/15 表示每 15 分钟执行一次. 而这个特性在商业 Unix ，比如 AIX 上就没有.</li></ul><h3 id="Quartz-Crontab格式"><a href="#Quartz-Crontab格式" class="headerlink" title="Quartz Crontab格式"></a>Quartz Crontab格式</h3><blockquote><p>一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。<br>Cron表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------------------- 秒 (0 - 59)</span><br><span class="line">|  +---------------- 分 (0 - 59)</span><br><span class="line">|  |  +------------- 时 (0 - 23)</span><br><span class="line">|  |  |  +---------- 日 (1 - 31)</span><br><span class="line">|  |  |  |  +------- 月 (1 - 12)</span><br><span class="line">|  |  |  |  |  +---- 周 (0 - 7) (Sunday=0 or 7)</span><br><span class="line">|  |  |  |  |  |  -- 年 (1970－2099)</span><br><span class="line">*  *  *  *  *  *  *    <span class="built_in">command</span> to be executed</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>逗号(‘,’) 指定列表值。如: “1,3,4,7,8”</li><li>中横线(‘-‘) 指定范围值 如 “1-6”, 代表 “1,2,3,4,5,6”</li><li>星号 (‘*’) 代表所有可能的值</li><li>问号（?）：该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；</li><li>斜杠(/)：x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；</li><li>L：该字符只在日期和星期字段中使用，代表“Last”的意思，但它在两个字段中意思不同。L在日期字段中，表示这个月份的最后一天，如一月的31号，非闰年二月的28号；如果L用在星期中，则表示星期六，等同于7。但是，如果L出现在星期字段里，而且在前面有一个数值 X，则表示“这个月的最后X天”，例如，6L表示该月的最后星期五；</li><li>W：该字符只能出现在日期字段里，是对前导日期的修饰，表示离该日期最近的工作日。例如15W表示离该月15号最近的工作日，如果该月15号是星期六，则匹配14号星期五；如果15日是星期日，则匹配16号星期一；如果15号是星期二，那结果就是15号星期二。但必须注意关联的匹配日期不能够跨月，如你指定1W，如果1号是星期六，结果匹配的是3号星期一，而非上个月最后的那天。W字符串只能指定单一日期，而不能指定日期范围；</li><li>LW组合：在日期字段可以组合使用LW，它的意思是当月的最后一个工作日；</li><li>井号(#)：该字符只能在星期字段中使用，表示当月某个工作日。如6#3表示当月的第三个星期五(6表示星期五，#3表示当前的第三个)，而4#5表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发；</li><li>C：该字符只在日期和星期字段中使用，代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如5C在日期字段中就相当于日历5日以后的第一天。1C在星期字段中相当于星期日后的第一天。</li></ul><div class="tip"><br>后面这几个针对星期的参数，不好记，交流起来都困难。不到万不得已，鬼才用。<br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;定时器大家都会用到，但JDK的Timer和ScheduledThreadPoolExecutor都只是提供固定频率的定时功能，很难满足业务需
      
    
    </summary>
    
      <category term="初级" scheme="http://java.jr-jr.com/categories/%E5%88%9D%E7%BA%A7/"/>
    
    
      <category term="linux" scheme="http://java.jr-jr.com/tags/linux/"/>
    
  </entry>
  
</feed>
